; Generated by Isabelle/LLVM-shallow
target datalayout = "e-m:e-p:64:64:64-a:0:64-n8:16:32:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f16:16:16-f32:32:32-f64:64:64-f128:128:128"
target triple = "x86_64-pc-linux-gnu"



declare void @isabelle_llvm_free(i8*)
declare i64 @fread_from_proof(i8*, i64)
declare i8* @isabelle_llvm_calloc(i64, i64)

attributes #0 = { strictfp }

define void @LLVM_DS_Array_arraycpy(i32* %dst, i32* %src, i64 %n) #0 {

  start:
    br label %while_start

  while_start:
    %i = phi i64 [ %x1, %while_body ], [ 0, %start ]
    %x = icmp ult i64 %i, %n
    br i1 %x, label %while_body, label %while_end

  while_body:
    %xa = getelementptr i32, i32* %src, i64 %i
    %xaa = load i32, i32* %xa
    %p = getelementptr i32, i32* %dst, i64 %i
    store i32 %xaa, i32* %p
    %x1 = add i64 %i, 1
    br label %while_start

  while_end:
    ret void
}

define void @LLVM_DS_Array_arraycpy1(i1* %dst, i1* %src, i64 %n) #0 {

  start:
    br label %while_start

  while_start:
    %i = phi i64 [ %x1, %while_body ], [ 0, %start ]
    %x = icmp ult i64 %i, %n
    br i1 %x, label %while_body, label %while_end

  while_body:
    %xa = getelementptr i1, i1* %src, i64 %i
    %xaa = load i1, i1* %xa
    %p = getelementptr i1, i1* %dst, i64 %i
    store i1 %xaa, i1* %p
    %x1 = add i64 %i, 1
    br label %while_start

  while_end:
    ret void
}

define void @LLVM_DS_Array_arrayset(i32* %dst, i32 %c, i64 %n) #0 {

  start:
    br label %while_start

  while_start:
    %i = phi i64 [ %x1, %while_body ], [ 0, %start ]
    %x = icmp ult i64 %i, %n
    br i1 %x, label %while_body, label %while_end

  while_body:
    %p = getelementptr i32, i32* %dst, i64 %i
    store i32 %c, i32* %p
    %x1 = add i64 %i, 1
    br label %while_start

  while_end:
    ret void
}

define void @DS_Clause_zcl_free_impl(i32* %x) #0 {

  start:
    call void @LLVM_DS_NArray_narray_free (i32* %x)
    ret void
}

define i32* @DS_Clause_zcl_make_impl({ i64, { i64, i32* } } %x) #0 {

  start:
    %l = extractvalue { i64, { i64, i32* } } %x, 0
    %xb = extractvalue { i64, { i64, i32* } } %x, 1
    %c = extractvalue { i64, i32* } %xb, 0
    %a = extractvalue { i64, i32* } %xb, 1
    %xba = add i64 %l, 1
    %xda = call i32* @LLVM_DS_NArray_narray_new_init (i64 %xba, i32 0)
    %xfa = insertvalue { i64, i32* } zeroinitializer, i64 0, 0
    %xga = insertvalue { i64, i32* } %xfa, i32* %xda, 1
    br label %while_start

  while_start:
    %xea = phi { i64, i32* } [ %x2, %while_body ], [ %xga, %start ]
    %a1 = extractvalue { i64, i32* } %xea, 0
    %a2 = extractvalue { i64, i32* } %xea, 1
    %xfaa = icmp slt i64 %a1, %l
    %x1 = and i1 %xfaa, 1
    br i1 %x1, label %while_body, label %while_end

  while_body:
    %a11 = extractvalue { i64, i32* } %xea, 0
    %a21 = extractvalue { i64, i32* } %xea, 1
    %la = extractvalue { i64, { i64, i32* } } %x, 0
    %xfaa1 = extractvalue { i64, { i64, i32* } } %x, 1
    %ca = extractvalue { i64, i32* } %xfaa1, 0
    %aa = extractvalue { i64, i32* } %xfaa1, 1
    %xgaa = getelementptr i32, i32* %aa, i64 %a11
    %xha = load i32, i32* %xgaa
    %p = getelementptr i32, i32* %a21, i64 %a11
    store i32 %xha, i32* %p
    %xla = add i64 %a11, 1
    %xma = insertvalue { i64, i32* } zeroinitializer, i64 %xla, 0
    %x2 = insertvalue { i64, i32* } %xma, i32* %a21, 1
    br label %while_start

  while_end:
    %a12 = extractvalue { i64, i32* } %xea, 0
    %x3 = extractvalue { i64, i32* } %xea, 1
    ret i32* %x3
}

define i1* @LLVM_DS_NArray_array_grow(i64 %newsz, i64 %oldsz, i1* %src) #0 {

  start:
    %tmp = icmp eq i64 %newsz, 0
    br i1 %tmp, label %then, label %else

  then:
    br label %ctd_if

  else:
    %t = getelementptr i1, i1* null, i64 1
    %a = ptrtoint i1* %t to i64
    %b = call i8* @isabelle_llvm_calloc (i64 %newsz, i64 %a)
    %x = bitcast i8* %b to i1*
    br label %ctd_if

  ctd_if:
    %dst = phi i1* [ %x, %else ], [ null, %then ]
    call void @LLVM_DS_Array_arraycpy1 (i1* %dst, i1* %src, i64 %oldsz)
    call void @LLVM_DS_NArray_narray_free2 (i1* %src)
    ret i1* %dst
}

define { i64, { i64, i8* } } @LRAT_Parsers_brd_new_impl() #0 {

  start:
    %tmpa = icmp eq i64 1048576, 0
    br i1 %tmpa, label %then, label %else

  then:
    br label %ctd_if

  else:
    %t = getelementptr i8, i8* null, i64 1
    %a = ptrtoint i8* %t to i64
    %b = call i8* @isabelle_llvm_calloc (i64 1048576, i64 %a)
    %x = bitcast i8* %b to i8*
    br label %ctd_if

  ctd_if:
    %xa = phi i8* [ %x, %else ], [ null, %then ]
    %xaa = insertvalue { i64, { i64, i8* } } zeroinitializer, i64 0, 0
    %xca = insertvalue { i64, i8* } zeroinitializer, i64 0, 0
    %tmpda = insertvalue { i64, i8* } %xca, i8* %xa, 1
    %x1 = insertvalue { i64, { i64, i8* } } %xaa, { i64, i8* } %tmpda, 1
    ret { i64, { i64, i8* } } %x1
}

define void @LLVM_DS_NArray_narray_free(i32* %p) #0 {

  start:
    %a = ptrtoint i32* %p to i64
    %b = ptrtoint i32* null to i64
    %tmp = icmp eq i64 %a, %b
    br i1 %tmp, label %then, label %else

  then:
    br label %ctd_if

  else:
    %c = bitcast i32* %p to i8*
    call void @isabelle_llvm_free (i8* %c)
    br label %ctd_if

  ctd_if:
    ret void
}

define void @LLVM_DS_NArray_narray_free1(i8* %p) #0 {

  start:
    %a = ptrtoint i8* %p to i64
    %b = ptrtoint i8* null to i64
    %tmp = icmp eq i64 %a, %b
    br i1 %tmp, label %then, label %else

  then:
    br label %ctd_if

  else:
    %c = bitcast i8* %p to i8*
    call void @isabelle_llvm_free (i8* %c)
    br label %ctd_if

  ctd_if:
    ret void
}

define void @LLVM_DS_NArray_narray_free2(i1* %p) #0 {

  start:
    %a = ptrtoint i1* %p to i64
    %b = ptrtoint i1* null to i64
    %tmp = icmp eq i64 %a, %b
    br i1 %tmp, label %then, label %else

  then:
    br label %ctd_if

  else:
    %c = bitcast i1* %p to i8*
    call void @isabelle_llvm_free (i8* %c)
    br label %ctd_if

  ctd_if:
    ret void
}

define void @LLVM_DS_NArray_narray_free3(i32** %p) #0 {

  start:
    %a = ptrtoint i32** %p to i64
    %b = ptrtoint i32** null to i64
    %tmp = icmp eq i64 %a, %b
    br i1 %tmp, label %then, label %else

  then:
    br label %ctd_if

  else:
    %c = bitcast i32** %p to i8*
    call void @isabelle_llvm_free (i8* %c)
    br label %ctd_if

  ctd_if:
    ret void
}

define { { i8, i1 }, i64 } @CNF_Parser_Impl_p_char_impl(i8 %x, { i8*, i64 } %x1, i64 %x2) #0 {

  start:
    %a1 = extractvalue { i8*, i64 } %x1, 0
    %a2 = extractvalue { i8*, i64 } %x1, 1
    %xb = sub i64 %a2, %x2
    %xaa = icmp eq i64 %xb, 0
    br i1 %xaa, label %then, label %else

  then:
    %xd = insertvalue { i8, i1 } zeroinitializer, i8 0, 0
    %tmpaa = insertvalue { i8, i1 } %xd, i1 1, 1
    %xba = insertvalue { { i8, i1 }, i64 } zeroinitializer, { i8, i1 } %tmpaa, 0
    %x3 = insertvalue { { i8, i1 }, i64 } %xba, i64 %x2, 1
    br label %ctd_if

  else:
    %a1a = extractvalue { i8*, i64 } %x1, 0
    %a2a = extractvalue { i8*, i64 } %x1, 1
    %xba1 = getelementptr i8, i8* %a1a, i64 %x2
    %xca = load i8, i8* %xba1
    %a1b = extractvalue { i8*, i64 } %x1, 0
    %a2b = extractvalue { i8*, i64 } %x1, 1
    %xda = add i64 %x2, 1
    %xea = icmp eq i8 %xca, %x
    br i1 %xea, label %thena, label %elsea

  thena:
    %xi = insertvalue { i8, i1 } zeroinitializer, i8 %xca, 0
    %tmpaa1 = insertvalue { i8, i1 } %xi, i1 0, 1
    %xfa = insertvalue { { i8, i1 }, i64 } zeroinitializer, { i8, i1 } %tmpaa1, 0
    %x4 = insertvalue { { i8, i1 }, i64 } %xfa, i64 %xda, 1
    br label %ctd_ifa

  elsea:
    %xi1 = insertvalue { i8, i1 } zeroinitializer, i8 %xca, 0
    %tmpaa2 = insertvalue { i8, i1 } %xi1, i1 1, 1
    %xfa1 = insertvalue { { i8, i1 }, i64 } zeroinitializer, { i8, i1 } %tmpaa2, 0
    %x5 = insertvalue { { i8, i1 }, i64 } %xfa1, i64 %xda, 1
    br label %ctd_ifa

  ctd_ifa:
    %x6 = phi { { i8, i1 }, i64 } [ %x5, %elsea ], [ %x4, %thena ]
    br label %ctd_if

  ctd_if:
    %x7 = phi { { i8, i1 }, i64 } [ %x6, %ctd_ifa ], [ %x3, %then ]
    ret { { i8, i1 }, i64 } %x7
}

define void @DS_Clause_Builder_cbld_free({ i32, { i64, { i64, i32* } } } %x) #0 {

  start:
    %a = extractvalue { i32, { i64, { i64, i32* } } } %x, 0
    %b = extractvalue { i32, { i64, { i64, i32* } } } %x, 1
    %xc = insertvalue { i32, { { i64, { i64, i32* } }, i1 } } zeroinitializer, i32 %a, 0
    %xd = insertvalue { { i64, { i64, i32* } }, i1 } zeroinitializer, { i64, { i64, i32* } } %b, 0
    %tmpb = insertvalue { { i64, { i64, i32* } }, i1 } %xd, i1 zeroinitializer, 1
    %tmpc = insertvalue { i32, { { i64, { i64, i32* } }, i1 } } %xc, { { i64, { i64, i32* } }, i1 } %tmpb, 1
    %c_1 = extractvalue { i32, { { i64, { i64, i32* } }, i1 } } %tmpc, 0
    %aa = extractvalue { i32, { i64, { i64, i32* } } } %x, 0
    %ba = extractvalue { i32, { i64, { i64, i32* } } } %x, 1
    %xba = insertvalue { i32, { { i64, { i64, i32* } }, i1 } } zeroinitializer, i32 %aa, 0
    %xj = insertvalue { { i64, { i64, i32* } }, i1 } zeroinitializer, { i64, { i64, i32* } } %ba, 0
    %tmpac = insertvalue { { i64, { i64, i32* } }, i1 } %xj, i1 zeroinitializer, 1
    %tmpad = insertvalue { i32, { { i64, { i64, i32* } }, i1 } } %xba, { { i64, { i64, i32* } }, i1 } %tmpac, 1
    %xda = extractvalue { i32, { { i64, { i64, i32* } }, i1 } } %tmpad, 1
    %c_11 = extractvalue { { i64, { i64, i32* } }, i1 } %xda, 0
    %c_2 = extractvalue { { i64, { i64, i32* } }, i1 } %xda, 1
    %uu = extractvalue { i64, { i64, i32* } } %c_11, 0
    %xaaa = extractvalue { i64, { i64, i32* } } %c_11, 1
    %uua = extractvalue { i64, i32* } %xaaa, 0
    %xbaa = extractvalue { i64, i32* } %xaaa, 1
    call void @LLVM_DS_NArray_narray_free (i32* %xbaa)
    ret void
}

define void @LRAT_Checker_Impl_cs_op_free({ i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %x) #0 {

  start:
    %c_1 = extractvalue { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %x, 0
    %c_2 = extractvalue { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %x, 1
    %c_11 = extractvalue { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } %c_2, 0
    %c_21 = extractvalue { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } %c_2, 1
    %c_12 = extractvalue { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } %c_21, 0
    %c_22 = extractvalue { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } %c_21, 1
    call void @DS_Clause_Database_cdb_free_impl ({ i64, i32** } %c_12)
    %c_13 = extractvalue { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } %c_22, 0
    %c_23 = extractvalue { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } %c_22, 1
    call void @DS_Clause_Builder_cbld_free ({ i32, { i64, { i64, i32* } } } %c_13)
    call void @DS_Reversible_Assignment_rpan_free ({ { i64, i1* }, { i64, { i64, i32* } } } %c_23)
    ret void
}

define { i8, { i64, { i64, i8* } } } @LRAT_Parsers_brd_refill_impl(i64 %x, i64 %x1, i8* %x2) #0 {

  start:
    %x3 = icmp eq i64 %x, %x1
    br i1 %x3, label %then, label %else

  then:
    %r = call i64 @fread_from_proof (i8* %x2, i64 1048576)
    %xaa = icmp slt i64 0, %r
    br i1 %xaa, label %thena, label %elsea

  thena:
    %xba = getelementptr i8, i8* %x2, i64 0
    %xc = load i8, i8* %xba
    %xda = add i64 0, 1
    %xea = insertvalue { i8, { i64, { i64, i8* } } } zeroinitializer, i8 %xc, 0
    %xf = insertvalue { i64, i8* } zeroinitializer, i64 %r, 0
    %tmpc = insertvalue { i64, i8* } %xf, i8* %x2, 1
    %xg = insertvalue { i64, { i64, i8* } } zeroinitializer, i64 %xda, 0
    %tmpd = insertvalue { i64, { i64, i8* } } %xg, { i64, i8* } %tmpc, 1
    %x4 = insertvalue { i8, { i64, { i64, i8* } } } %xea, { i64, { i64, i8* } } %tmpd, 1
    br label %ctd_ifa

  elsea:
    %xba1 = insertvalue { i8, { i64, { i64, i8* } } } zeroinitializer, i8 0, 0
    %xc1 = insertvalue { i64, i8* } zeroinitializer, i64 0, 0
    %tmpac = insertvalue { i64, i8* } %xc1, i8* %x2, 1
    %xd = insertvalue { i64, { i64, i8* } } zeroinitializer, i64 1, 0
    %tmpc1 = insertvalue { i64, { i64, i8* } } %xd, { i64, i8* } %tmpac, 1
    %x5 = insertvalue { i8, { i64, { i64, i8* } } } %xba1, { i64, { i64, i8* } } %tmpc1, 1
    br label %ctd_ifa

  ctd_ifa:
    %x6 = phi { i8, { i64, { i64, i8* } } } [ %x5, %elsea ], [ %x4, %thena ]
    br label %ctd_if

  else:
    %xaa1 = insertvalue { i8, { i64, { i64, i8* } } } zeroinitializer, i8 0, 0
    %xb = insertvalue { i64, i8* } zeroinitializer, i64 %x1, 0
    %tmpb = insertvalue { i64, i8* } %xb, i8* %x2, 1
    %xc2 = insertvalue { i64, { i64, i8* } } zeroinitializer, i64 %x, 0
    %tmpc2 = insertvalue { i64, { i64, i8* } } %xc2, { i64, i8* } %tmpb, 1
    %x7 = insertvalue { i8, { i64, { i64, i8* } } } %xaa1, { i64, { i64, i8* } } %tmpc2, 1
    br label %ctd_if

  ctd_if:
    %x8 = phi { i8, { i64, { i64, i8* } } } [ %x7, %else ], [ %x6, %ctd_ifa ]
    ret { i8, { i64, { i64, i8* } } } %x8
}

define { i64, { i64, { i64, i8* } } } @LRAT_Parsers_brd_rs_new_impl(i64 %x) #0 {

  start:
    %x1 = call { i64, { i64, i8* } } @LRAT_Parsers_brd_new_impl ()
    %xaa = insertvalue { i64, { i64, { i64, i8* } } } zeroinitializer, i64 %x, 0
    %x2 = insertvalue { i64, { i64, { i64, i8* } } } %xaa, { i64, { i64, i8* } } %x1, 1
    ret { i64, { i64, { i64, i8* } } } %x2
}

define { i64, { i64, i32* } } @LLVM_DS_Array_List_arl_resize(i64 %c, { i64, { i64, i32* } } %al) #0 {

  start:
    %l = extractvalue { i64, { i64, i32* } } %al, 0
    %xb = extractvalue { i64, { i64, i32* } } %al, 1
    %c1 = extractvalue { i64, i32* } %xb, 0
    %a = extractvalue { i64, i32* } %xb, 1
    %r = sub i64 0, 1
    %max = lshr i64 %r, 1
    %maxa = udiv i64 %max, 2
    %b = icmp ule i64 %c1, %maxa
    br i1 %b, label %then, label %else

  then:
    %ca = mul i64 %c1, 2
    %cok = icmp sle i64 %c, %ca
    br i1 %cok, label %thena, label %elsea

  thena:
    br label %ctd_ifa

  elsea:
    br label %ctd_ifa

  ctd_ifa:
    %x = phi i64 [ %c, %elsea ], [ %ca, %thena ]
    br label %ctd_if

  else:
    br label %ctd_if

  ctd_if:
    %ca1 = phi i64 [ %c, %else ], [ %x, %ctd_ifa ]
    %tmpa = icmp eq i64 %ca1, 0
    br i1 %tmpa, label %thenb, label %elseb

  thenb:
    br label %ctd_ifb

  elseb:
    %t = getelementptr i32, i32* null, i64 1
    %d = ptrtoint i32* %t to i64
    %e = call i8* @isabelle_llvm_calloc (i64 %ca1, i64 %d)
    %x1 = bitcast i8* %e to i32*
    br label %ctd_ifb

  ctd_ifb:
    %a1 = phi i32* [ %x1, %elseb ], [ null, %thenb ]
    call void @LLVM_DS_Array_arraycpy (i32* %a1, i32* %a, i64 %l)
    call void @LLVM_DS_NArray_narray_free (i32* %a)
    %xaa = insertvalue { i64, { i64, i32* } } zeroinitializer, i64 %l, 0
    %xja = insertvalue { i64, i32* } zeroinitializer, i64 %ca1, 0
    %tmpca = insertvalue { i64, i32* } %xja, i32* %a1, 1
    %x2 = insertvalue { i64, { i64, i32* } } %xaa, { i64, i32* } %tmpca, 1
    ret { i64, { i64, i32* } } %x2
}

define i32** @LRAT_Sepref_Base_wo_grow_impl(i64 %x, i32** %x1, i64 %x2) #0 {

  start:
    %tmp = icmp eq i64 %x2, 0
    br i1 %tmp, label %then, label %else

  then:
    br label %ctd_if

  else:
    %t = getelementptr i32*, i32** null, i64 1
    %a = ptrtoint i32** %t to i64
    %b = call i8* @isabelle_llvm_calloc (i64 %x2, i64 %a)
    %x3 = bitcast i8* %b to i32**
    br label %ctd_if

  ctd_if:
    %xa = phi i32** [ %x3, %else ], [ null, %then ]
    %xba = insertvalue { i32**, i32** } zeroinitializer, i32** %x1, 0
    %tmpaa = insertvalue { i32**, i32** } %xba, i32** %xa, 1
    %xca = insertvalue { i64, { i32**, i32** } } zeroinitializer, i64 0, 0
    %xda = insertvalue { i64, { i32**, i32** } } %xca, { i32**, i32** } %tmpaa, 1
    br label %while_start

  while_start:
    %xaa = phi { i64, { i32**, i32** } } [ %x5, %while_body ], [ %xda, %ctd_if ]
    %a1 = extractvalue { i64, { i32**, i32** } } %xaa, 0
    %xbaa = extractvalue { i64, { i32**, i32** } } %xaa, 1
    %a1a = extractvalue { i32**, i32** } %xbaa, 0
    %a2a = extractvalue { i32**, i32** } %xbaa, 1
    %x4 = icmp slt i64 %a1, %x
    br i1 %x4, label %while_body, label %while_end

  while_body:
    %a11 = extractvalue { i64, { i32**, i32** } } %xaa, 0
    %xbaa1 = extractvalue { i64, { i32**, i32** } } %xaa, 1
    %a1a1 = extractvalue { i32**, i32** } %xbaa1, 0
    %a2a1 = extractvalue { i32**, i32** } %xbaa1, 1
    %xcaa = getelementptr i32*, i32** %a1a1, i64 %a11
    %r = load i32*, i32** %xcaa
    %xdaa = getelementptr i32*, i32** %a2a1, i64 %a11
    %ra = load i32*, i32** %xdaa
    %p = getelementptr i32*, i32** %a2a1, i64 %a11
    store i32* %r, i32** %p
    %xfa = add i64 %a11, 1
    %xga = insertvalue { i64, { i32**, i32** } } zeroinitializer, i64 %xfa, 0
    %xka = insertvalue { i32**, i32** } zeroinitializer, i32** %a1a1, 0
    %tmpca = insertvalue { i32**, i32** } %xka, i32** %a2a1, 1
    %x5 = insertvalue { i64, { i32**, i32** } } %xga, { i32**, i32** } %tmpca, 1
    br label %while_start

  while_end:
    %a12 = extractvalue { i64, { i32**, i32** } } %xaa, 0
    %xbaa2 = extractvalue { i64, { i32**, i32** } } %xaa, 1
    %a1a2 = extractvalue { i32**, i32** } %xbaa2, 0
    %a2a2 = extractvalue { i32**, i32** } %xbaa2, 1
    call void @LLVM_DS_NArray_narray_free3 (i32** %a1a2)
    ret i32** %a2a2
}

define i32* @LLVM_DS_NArray_narray_new_init(i64 %n, i32 %c) #0 {

  start:
    %tmp = icmp eq i64 %n, 0
    br i1 %tmp, label %then, label %else

  then:
    br label %ctd_if

  else:
    %t = getelementptr i32, i32* null, i64 1
    %a = ptrtoint i32* %t to i64
    %b = call i8* @isabelle_llvm_calloc (i64 %n, i64 %a)
    %x = bitcast i8* %b to i32*
    br label %ctd_if

  ctd_if:
    %r = phi i32* [ %x, %else ], [ null, %then ]
    call void @LLVM_DS_Array_arrayset (i32* %r, i32 %c, i64 %n)
    ret i32* %r
}

define i8 @lrat_checker(i8* %x, i64 %x1) #0 {

  start:
    %x2 = call { i8*, i64 } @LRAT_Checker_Impl_mk_rdmem_inp_impl (i8* %x, i64 %x1)
    %x3 = call i1 @LRAT_Checker_Impl_read_check_lrat_impl ({ i8*, i64 } %x2)
    %x4 = call i8* @LRAT_Checker_Impl_rdmem_data_impl ({ i8*, i64 } %x2)
    br i1 %x3, label %then, label %else

  then:
    br label %ctd_if

  else:
    br label %ctd_if

  ctd_if:
    %x5 = phi i8 [ 0, %else ], [ 1, %then ]
    ret i8 %x5
}

define { i32, { i64, { i64, i32* } } } @DS_Clause_Builder_cbld_new_impl(i64 %x) #0 {

  start:
    %x1 = call { i64, { i64, i32* } } @DS_Clause_Buffer_cbuf_empty_impl ()
    %xaa = insertvalue { i32, { i64, { i64, i32* } } } zeroinitializer, i32 0, 0
    %x2 = insertvalue { i32, { i64, { i64, i32* } } } %xaa, { i64, { i64, i32* } } %x1, 1
    ret { i32, { i64, { i64, i32* } } } %x2
}

define { i64, { i64, i32* } } @DS_Clause_Buffer_cbuf_empty_impl() #0 {

  start:
    %tmp = icmp eq i64 8, 0
    br i1 %tmp, label %then, label %else

  then:
    br label %ctd_if

  else:
    %t = getelementptr i32, i32* null, i64 1
    %a = ptrtoint i32* %t to i64
    %b = call i8* @isabelle_llvm_calloc (i64 8, i64 %a)
    %x = bitcast i8* %b to i32*
    br label %ctd_if

  ctd_if:
    %aa = phi i32* [ %x, %else ], [ null, %then ]
    %xb = insertvalue { i64, { i64, i32* } } zeroinitializer, i64 0, 0
    %xca = insertvalue { i64, i32* } zeroinitializer, i64 8, 0
    %tmpba = insertvalue { i64, i32* } %xca, i32* %aa, 1
    %x1 = insertvalue { i64, { i64, i32* } } %xb, { i64, i32* } %tmpba, 1
    ret { i64, { i64, i32* } } %x1
}

define { i64, { i64, i32* } } @DS_Clause_Buffer_cbuf_flush_impl({ i64, { i64, i32* } } %x) #0 {

  start:
    %l = extractvalue { i64, { i64, i32* } } %x, 0
    %xb = extractvalue { i64, { i64, i32* } } %x, 1
    %c = extractvalue { i64, i32* } %xb, 0
    %a = extractvalue { i64, i32* } %xb, 1
    %xaa = insertvalue { i64, { i64, i32* } } zeroinitializer, i64 0, 0
    %xfa = insertvalue { i64, i32* } zeroinitializer, i64 %c, 0
    %tmpba = insertvalue { i64, i32* } %xfa, i32* %a, 1
    %x1 = insertvalue { i64, { i64, i32* } } %xaa, { i64, i32* } %tmpba, 1
    ret { i64, { i64, i32* } } %x1
}

define void @DS_Clause_Database_cdb_free_impl({ i64, i32** } %x) #0 {

  start:
    %a = extractvalue { i64, i32** } %x, 0
    %x1 = extractvalue { i64, i32** } %x, 1
    call void @Monadify_M_CONST_LRAT_Sepref_Base_woarray_free_impl_Sepref_HOL_Bindings_dflt_option_free_option_LLVM_Shallow_ll_ptrcmp_eq_LLVM_Shallow_null_DS_Clause_zcl_free_impl (i64 %a, i32** %x1)
    ret void
}

define { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } @CNF_Parser_Impl_builder_init_impl(i64 %x, i64 %x1) #0 {

  start:
    %x2 = add i64 %x, %x1
    %xa = call { i32, { i64, { i64, i32* } } } @DS_Clause_Builder_cbld_new_impl (i64 %x2)
    %xb = call { i64, i32** } @DS_Clause_Database_cdb_empty_impl ()
    %xca = insertvalue { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } zeroinitializer, i64 1, 0
    %xda = insertvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } zeroinitializer, { i32, { i64, { i64, i32* } } } %xa, 0
    %tmpba = insertvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %xda, { i64, i32** } %xb, 1
    %x3 = insertvalue { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %xca, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %tmpba, 1
    ret { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %x3
}

define { i64, { i64, i32* } } @DS_Clause_Buffer_cbuf_insert_impl(i32 %x, { i64, { i64, i32* } } %x1) #0 {

  start:
    %l = extractvalue { i64, { i64, i32* } } %x1, 0
    %xb = extractvalue { i64, { i64, i32* } } %x1, 1
    %c = extractvalue { i64, i32* } %xb, 0
    %a = extractvalue { i64, i32* } %xb, 1
    %lb = add i64 %l, 1
    %lc = extractvalue { i64, { i64, i32* } } %x1, 0
    %xaa = extractvalue { i64, { i64, i32* } } %x1, 1
    %ca = extractvalue { i64, i32* } %xaa, 0
    %aa = extractvalue { i64, i32* } %xaa, 1
    %cok = icmp sle i64 %lb, %ca
    br i1 %cok, label %then, label %else

  then:
    %xba = insertvalue { i64, { i64, i32* } } zeroinitializer, i64 %lc, 0
    %xka = insertvalue { i64, i32* } zeroinitializer, i64 %ca, 0
    %tmpaa = insertvalue { i64, i32* } %xka, i32* %aa, 1
    %x2 = insertvalue { i64, { i64, i32* } } %xba, { i64, i32* } %tmpaa, 1
    br label %ctd_if

  else:
    %xja = insertvalue { i64, i32* } zeroinitializer, i64 %ca, 0
    %tmpa = insertvalue { i64, i32* } %xja, i32* %aa, 1
    %xka1 = insertvalue { i64, { i64, i32* } } zeroinitializer, i64 %lc, 0
    %x3 = insertvalue { i64, { i64, i32* } } %xka1, { i64, i32* } %tmpa, 1
    %x4 = call { i64, { i64, i32* } } @LLVM_DS_Array_List_arl_resize (i64 %lb, { i64, { i64, i32* } } %x3)
    br label %ctd_if

  ctd_if:
    %al = phi { i64, { i64, i32* } } [ %x4, %else ], [ %x2, %then ]
    %ld = extractvalue { i64, { i64, i32* } } %al, 0
    %xba1 = extractvalue { i64, { i64, i32* } } %al, 1
    %cb = extractvalue { i64, i32* } %xba1, 0
    %ab = extractvalue { i64, i32* } %xba1, 1
    %p = getelementptr i32, i32* %ab, i64 %ld
    store i32 %x, i32* %p
    %le = add i64 %ld, 1
    %xca = insertvalue { i64, { i64, i32* } } zeroinitializer, i64 %le, 0
    %xpa = insertvalue { i64, i32* } zeroinitializer, i64 %cb, 0
    %tmpaa1 = insertvalue { i64, i32* } %xpa, i32* %ab, 1
    %x5 = insertvalue { i64, { i64, i32* } } %xca, { i64, i32* } %tmpaa1, 1
    ret { i64, { i64, i32* } } %x5
}

define { i64, i32** } @DS_Clause_Database_cdb_empty_impl() #0 {

  start:
    %tmpa = icmp eq i64 16, 0
    br i1 %tmpa, label %then, label %else

  then:
    br label %ctd_if

  else:
    %t = getelementptr i32*, i32** null, i64 1
    %a = ptrtoint i32** %t to i64
    %b = call i8* @isabelle_llvm_calloc (i64 16, i64 %a)
    %x = bitcast i8* %b to i32**
    br label %ctd_if

  ctd_if:
    %xa = phi i32** [ %x, %else ], [ null, %then ]
    %xaa = insertvalue { i64, i32** } zeroinitializer, i64 16, 0
    %x1 = insertvalue { i64, i32** } %xaa, i32** %xa, 1
    ret { i64, i32** } %x1
}

define { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } @LRAT_Checker_Impl_proof_step_impl(i64 %x, { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } %x1) #0 {

  start:
    %a1 = extractvalue { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } %x1, 0
    %xb = extractvalue { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } %x1, 1
    %a1a = extractvalue { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %xb, 0
    %xaa = extractvalue { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %xb, 1
    %a1b = extractvalue { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %xaa, 0
    %xba = extractvalue { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %xaa, 1
    %a1c = extractvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %xba, 0
    %a2c = extractvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %xba, 1
    br i1 %a1, label %then, label %else

  then:
    %xca = insertvalue { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } zeroinitializer, i1 %a1, 0
    %xja = insertvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } zeroinitializer, { i32, { i64, { i64, i32* } } } %a1c, 0
    %tmpaa = insertvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %xja, { i64, i32** } %a2c, 1
    %xka = insertvalue { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } zeroinitializer, { { i64, i1* }, { i64, { i64, i32* } } } %a1b, 0
    %tmpba = insertvalue { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %xka, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %tmpaa, 1
    %xla = insertvalue { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } zeroinitializer, i1 %a1a, 0
    %tmpca = insertvalue { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %xla, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %tmpba, 1
    %x2 = insertvalue { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } %xca, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %tmpca, 1
    br label %ctd_if

  else:
    %xca1 = call { i32, i1 } @LRAT_Checker_Impl_cdb_check_uot_impl ({ { i64, i1* }, { i64, { i64, i32* } } } %a1b, { i64, i32** } %a2c, i64 %x)
    %a1d = extractvalue { i32, i1 } %xca1, 0
    %a2d = extractvalue { i32, i1 } %xca1, 1
    br i1 %a2d, label %thena, label %elsea

  thena:
    %xda = insertvalue { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } zeroinitializer, i1 %a2d, 0
    %xla1 = insertvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } zeroinitializer, { i32, { i64, { i64, i32* } } } %a1c, 0
    %tmpaa1 = insertvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %xla1, { i64, i32** } %a2c, 1
    %xma = insertvalue { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } zeroinitializer, { { i64, i1* }, { i64, { i64, i32* } } } %a1b, 0
    %tmpba1 = insertvalue { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %xma, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %tmpaa1, 1
    %xna = insertvalue { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } zeroinitializer, i1 %a1a, 0
    %tmpca1 = insertvalue { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %xna, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %tmpba1, 1
    %x3 = insertvalue { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } %xda, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %tmpca1, 1
    br label %ctd_ifa

  elsea:
    %xda1 = icmp eq i32 %a1d, 0
    br i1 %xda1, label %thenb, label %elseb

  thenb:
    %xea = insertvalue { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } zeroinitializer, i1 %a1, 0
    %xma1 = insertvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } zeroinitializer, { i32, { i64, { i64, i32* } } } %a1c, 0
    %tmpaa2 = insertvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %xma1, { i64, i32** } %a2c, 1
    %xna1 = insertvalue { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } zeroinitializer, { { i64, i1* }, { i64, { i64, i32* } } } %a1b, 0
    %tmpab = insertvalue { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %xna1, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %tmpaa2, 1
    %xoa = insertvalue { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } zeroinitializer, i1 1, 0
    %tmpbc = insertvalue { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %xoa, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %tmpab, 1
    %x4 = insertvalue { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } %xea, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %tmpbc, 1
    br label %ctd_ifb

  elseb:
    %a = extractvalue { { i64, i1* }, { i64, { i64, i32* } } } %a1b, 0
    %b = extractvalue { { i64, i1* }, { i64, { i64, i32* } } } %a1b, 1
    %xla2 = insertvalue { { i64, i1* }, { { i64, { i64, i32* } }, i1 } } zeroinitializer, { i64, i1* } %a, 0
    %xo = insertvalue { { i64, { i64, i32* } }, i1 } zeroinitializer, { i64, { i64, i32* } } %b, 0
    %tmpb = insertvalue { { i64, { i64, i32* } }, i1 } %xo, i1 zeroinitializer, 1
    %tmpc = insertvalue { { i64, i1* }, { { i64, { i64, i32* } }, i1 } } %xla2, { { i64, { i64, i32* } }, i1 } %tmpb, 1
    %a1e = extractvalue { { i64, i1* }, { { i64, { i64, i32* } }, i1 } } %tmpc, 0
    %aa = extractvalue { { i64, i1* }, { i64, { i64, i32* } } } %a1b, 0
    %ba = extractvalue { { i64, i1* }, { i64, { i64, i32* } } } %a1b, 1
    %xna2 = insertvalue { { i64, i1* }, { { i64, { i64, i32* } }, i1 } } zeroinitializer, { i64, i1* } %aa, 0
    %xt = insertvalue { { i64, { i64, i32* } }, i1 } zeroinitializer, { i64, { i64, i32* } } %ba, 0
    %tmpac = insertvalue { { i64, { i64, i32* } }, i1 } %xt, i1 zeroinitializer, 1
    %tmpad = insertvalue { { i64, i1* }, { { i64, { i64, i32* } }, i1 } } %xna2, { { i64, { i64, i32* } }, i1 } %tmpac, 1
    %xga = extractvalue { { i64, i1* }, { { i64, { i64, i32* } }, i1 } } %tmpad, 1
    %a1aa = extractvalue { { i64, { i64, i32* } }, i1 } %xga, 0
    %a2a = extractvalue { { i64, { i64, i32* } }, i1 } %xga, 1
    %xha = zext i32 %a1d to i64
    %a1f = extractvalue { i64, i1* } %a1e, 0
    %a2 = extractvalue { i64, i1* } %a1e, 1
    %p = getelementptr i1, i1* %a2, i64 %xha
    store i1 1, i1* %p
    %xja1 = insertvalue { i64, i1* } zeroinitializer, i64 %a1f, 0
    %xka1 = insertvalue { i64, i1* } %xja1, i1* %a2, 1
    %l = extractvalue { i64, { i64, i32* } } %a1aa, 0
    %xlaa = extractvalue { i64, { i64, i32* } } %a1aa, 1
    %c = extractvalue { i64, i32* } %xlaa, 0
    %ab = extractvalue { i64, i32* } %xlaa, 1
    %lb = add i64 %l, 1
    %lc = extractvalue { i64, { i64, i32* } } %a1aa, 0
    %xmaa = extractvalue { i64, { i64, i32* } } %a1aa, 1
    %ca = extractvalue { i64, i32* } %xmaa, 0
    %aaa = extractvalue { i64, i32* } %xmaa, 1
    %cok = icmp sle i64 %lb, %ca
    br i1 %cok, label %thenc, label %elsec

  thenc:
    %xnaa = insertvalue { i64, { i64, i32* } } zeroinitializer, i64 %lc, 0
    %yfa = insertvalue { i64, i32* } zeroinitializer, i64 %ca, 0
    %tmpea = insertvalue { i64, i32* } %yfa, i32* %aaa, 1
    %x5 = insertvalue { i64, { i64, i32* } } %xnaa, { i64, i32* } %tmpea, 1
    br label %ctd_ifc

  elsec:
    %yea = insertvalue { i64, i32* } zeroinitializer, i64 %ca, 0
    %tmpda = insertvalue { i64, i32* } %yea, i32* %aaa, 1
    %yfa1 = insertvalue { i64, { i64, i32* } } zeroinitializer, i64 %lc, 0
    %x6 = insertvalue { i64, { i64, i32* } } %yfa1, { i64, i32* } %tmpda, 1
    %x7 = call { i64, { i64, i32* } } @LLVM_DS_Array_List_arl_resize (i64 %lb, { i64, { i64, i32* } } %x6)
    br label %ctd_ifc

  ctd_ifc:
    %al = phi { i64, { i64, i32* } } [ %x7, %elsec ], [ %x5, %thenc ]
    %ld = extractvalue { i64, { i64, i32* } } %al, 0
    %xnaa1 = extractvalue { i64, { i64, i32* } } %al, 1
    %cb = extractvalue { i64, i32* } %xnaa1, 0
    %aba = extractvalue { i64, i32* } %xnaa1, 1
    %pa = getelementptr i32, i32* %aba, i64 %ld
    store i32 %a1d, i32* %pa
    %le = add i64 %ld, 1
    %xoaa = insertvalue { i64, { i64, i32* } } zeroinitializer, i64 %le, 0
    %yka = insertvalue { i64, i32* } zeroinitializer, i64 %cb, 0
    %tmpea1 = insertvalue { i64, i32* } %yka, i32* %aba, 1
    %xpaa = insertvalue { i64, { i64, i32* } } %xoaa, { i64, i32* } %tmpea1, 1
    %xqaa = insertvalue { { i64, i1* }, { i64, { i64, i32* } } } zeroinitializer, { i64, i1* } %xka1, 0
    %xraa = insertvalue { { i64, i1* }, { i64, { i64, i32* } } } %xqaa, { i64, { i64, i32* } } %xpaa, 1
    %xsaa = insertvalue { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } zeroinitializer, i1 %a1, 0
    %ypa = insertvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } zeroinitializer, { i32, { i64, { i64, i32* } } } %a1c, 0
    %tmpha = insertvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %ypa, { i64, i32** } %a2c, 1
    %yqa = insertvalue { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } zeroinitializer, { { i64, i1* }, { i64, { i64, i32* } } } %xraa, 0
    %tmpia = insertvalue { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %yqa, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %tmpha, 1
    %yra = insertvalue { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } zeroinitializer, i1 %a1a, 0
    %tmpja = insertvalue { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %yra, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %tmpia, 1
    %x8 = insertvalue { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } %xsaa, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %tmpja, 1
    br label %ctd_ifb

  ctd_ifb:
    %x9 = phi { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } [ %x8, %ctd_ifc ], [ %x4, %thenb ]
    br label %ctd_ifa

  ctd_ifa:
    %x10 = phi { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } [ %x9, %ctd_ifb ], [ %x3, %thena ]
    br label %ctd_if

  ctd_if:
    %x11 = phi { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } [ %x10, %ctd_ifa ], [ %x2, %then ]
    ret { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } %x11
}

define i8* @LRAT_Checker_Impl_rdmem_data_impl({ i8*, i64 } %x) #0 {

  start:
    %a1 = extractvalue { i8*, i64 } %x, 0
    %a2 = extractvalue { i8*, i64 } %x, 1
    ret i8* %a1
}

define { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } @CNF_Parser_Impl_parse_clause2_impl({ i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %x, { i8*, i64 } %x1, i64 %x2) #0 {

  start:
    %xa = insertvalue { i1, i1 } zeroinitializer, i1 0, 0
    %tmpba = insertvalue { i1, i1 } %xa, i1 0, 1
    %xaa = insertvalue { i64, { i1, i1 } } zeroinitializer, i64 %x2, 0
    %tmpca = insertvalue { i64, { i1, i1 } } %xaa, { i1, i1 } %tmpba, 1
    %xba = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } zeroinitializer, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %x, 0
    %xca = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } %xba, { i64, { i1, i1 } } %tmpca, 1
    br label %while_start

  while_start:
    %xda = phi { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } [ %x34, %ctd_if ], [ %xca, %start ]
    %a1 = extractvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } %xda, 0
    %xaaa = extractvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } %xda, 1
    %a1a = extractvalue { i64, { i1, i1 } } %xaaa, 0
    %xbaa = extractvalue { i64, { i1, i1 } } %xaaa, 1
    %a1b = extractvalue { i1, i1 } %xbaa, 0
    %a2b = extractvalue { i1, i1 } %xbaa, 1
    %x3 = add i1 %a2b, 1
    br i1 %x3, label %while_body, label %while_end

  while_body:
    %a11 = extractvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } %xda, 0
    %xaaa1 = extractvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } %xda, 1
    %a1a1 = extractvalue { i64, { i1, i1 } } %xaaa1, 0
    %xbaa1 = extractvalue { i64, { i1, i1 } } %xaaa1, 1
    %a1b1 = extractvalue { i1, i1 } %xbaa1, 0
    %a2b1 = extractvalue { i1, i1 } %xbaa1, 1
    %a1c = extractvalue { i8*, i64 } %x1, 0
    %a2 = extractvalue { i8*, i64 } %x1, 1
    %xcaa = sub i64 %a2, %a1a1
    %xdaa = icmp eq i64 %xcaa, 0
    br i1 %xdaa, label %then, label %else

  then:
    %xeaa = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } zeroinitializer, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %a11, 0
    %xoa = insertvalue { i1, i1 } zeroinitializer, i1 1, 0
    %tmpfa = insertvalue { i1, i1 } %xoa, i1 1, 1
    %xpa = insertvalue { i64, { i1, i1 } } zeroinitializer, i64 %a1a1, 0
    %tmpga = insertvalue { i64, { i1, i1 } } %xpa, { i1, i1 } %tmpfa, 1
    %x4 = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } %xeaa, { i64, { i1, i1 } } %tmpga, 1
    br label %ctd_if

  else:
    %a1d = extractvalue { i8*, i64 } %x1, 0
    %a2a = extractvalue { i8*, i64 } %x1, 1
    %xeaa1 = getelementptr i8, i8* %a1d, i64 %a1a1
    %xfaa = load i8, i8* %xeaa1
    %xga = icmp eq i8 %xfaa, 48
    br i1 %xga, label %thena, label %elsea

  thena:
    %a1e = extractvalue { i8*, i64 } %x1, 0
    %a2c = extractvalue { i8*, i64 } %x1, 1
    %xha = add i64 %a1a1, 1
    %xia = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } zeroinitializer, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %a11, 0
    %xua = insertvalue { i1, i1 } zeroinitializer, i1 0, 0
    %tmpfa1 = insertvalue { i1, i1 } %xua, i1 1, 1
    %xva = insertvalue { i64, { i1, i1 } } zeroinitializer, i64 %xha, 0
    %tmpga1 = insertvalue { i64, { i1, i1 } } %xva, { i1, i1 } %tmpfa1, 1
    %x5 = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } %xia, { i64, { i1, i1 } } %tmpga1, 1
    br label %ctd_ifa

  elsea:
    %a1e1 = extractvalue { i8*, i64 } %x1, 0
    %a2c1 = extractvalue { i8*, i64 } %x1, 1
    %xha1 = getelementptr i8, i8* %a1e1, i64 %a1a1
    %xia1 = load i8, i8* %xha1
    %xja = icmp eq i8 %xia1, 45
    br i1 %xja, label %thenb, label %elseb

  thenb:
    %a1f = extractvalue { i8*, i64 } %x1, 0
    %a2d = extractvalue { i8*, i64 } %x1, 1
    %xka = add i64 %a1a1, 1
    %xla = insertvalue { i1, i64 } zeroinitializer, i1 1, 0
    %x6 = insertvalue { i1, i64 } %xla, i64 %xka, 1
    br label %ctd_ifb

  elseb:
    %xka1 = insertvalue { i1, i64 } zeroinitializer, i1 0, 0
    %x7 = insertvalue { i1, i64 } %xka1, i64 %a1a1, 1
    br label %ctd_ifb

  ctd_ifb:
    %xka2 = phi { i1, i64 } [ %x7, %elseb ], [ %x6, %thenb ]
    %a1f1 = extractvalue { i1, i64 } %xka2, 0
    %a2d1 = extractvalue { i1, i64 } %xka2, 1
    %a1g = extractvalue { i8*, i64 } %x1, 0
    %a2e = extractvalue { i8*, i64 } %x1, 1
    %xla1 = sub i64 %a2e, %a2d1
    %xma = icmp eq i64 %xla1, 0
    br i1 %xma, label %thenc, label %elsec

  thenc:
    %xna = trunc i64 1 to i32
    %xoa1 = mul i32 2, %xna
    %xya = insertvalue { i32, i1 } zeroinitializer, i32 %xoa1, 0
    %tmpab = insertvalue { i32, i1 } %xya, i1 1, 1
    %xpa1 = insertvalue { { i32, i1 }, i64 } zeroinitializer, { i32, i1 } %tmpab, 0
    %x8 = insertvalue { { i32, i1 }, i64 } %xpa1, i64 %a2d1, 1
    br label %ctd_ifc

  elsec:
    %a1h = extractvalue { i8*, i64 } %x1, 0
    %a2f = extractvalue { i8*, i64 } %x1, 1
    %xna1 = getelementptr i8, i8* %a1h, i64 %a2d1
    %xoa2 = load i8, i8* %xna1
    %a1i = extractvalue { i8*, i64 } %x1, 0
    %a2g = extractvalue { i8*, i64 } %x1, 1
    %xpa2 = add i64 %a2d1, 1
    %xqa = icmp ule i8 49, %xoa2
    %xra = icmp ule i8 %xoa2, 57
    %xsa = and i1 %xqa, %xra
    %xta = add i1 %xsa, 1
    br i1 %xta, label %thend, label %elsed

  thend:
    %xua1 = trunc i64 1 to i32
    %yfa = insertvalue { i32, i1 } zeroinitializer, i32 %xua1, 0
    %tmpab1 = insertvalue { i32, i1 } %yfa, i1 1, 1
    %xva1 = insertvalue { { i32, i1 }, i64 } zeroinitializer, { i32, i1 } %tmpab1, 0
    %x9 = insertvalue { { i32, i1 }, i64 } %xva1, i64 %xpa2, 1
    br label %ctd_ifd

  elsed:
    %tmpe = sub i8 %xoa2, 48
    %xua2 = zext i8 %tmpe to i64
    %yga = insertvalue { i64, i1 } zeroinitializer, i64 %xua2, 0
    %tmpga2 = insertvalue { i64, i1 } %yga, i1 0, 1
    %yha = insertvalue { i64, { i64, i1 } } zeroinitializer, i64 %xpa2, 0
    %yia = insertvalue { i64, { i64, i1 } } %yha, { i64, i1 } %tmpga2, 1
    br label %while_starta

  while_starta:
    %xva2 = phi { i64, { i64, i1 } } [ %x14, %ctd_ife ], [ %yia, %elsed ]
    %a1j = extractvalue { i64, { i64, i1 } } %xva2, 0
    %xwa = extractvalue { i64, { i64, i1 } } %xva2, 1
    %a1aa = extractvalue { i64, i1 } %xwa, 0
    %a2aa = extractvalue { i64, i1 } %xwa, 1
    %xxa = add i1 %a2aa, 1
    %a1k = extractvalue { i8*, i64 } %x1, 0
    %a2h = extractvalue { i8*, i64 } %x1, 1
    %xya1 = sub i64 %a2h, %a1j
    %xza = icmp eq i64 %xya1, 0
    %yaa = add i1 %xza, 1
    %yba = icmp sle i64 %a1aa, 2147483647
    %x10 = and i1 %yaa, %yba
    %x11 = and i1 %xxa, %x10
    br i1 %x11, label %while_bodya, label %while_enda

  while_bodya:
    %a1j1 = extractvalue { i64, { i64, i1 } } %xva2, 0
    %xwa1 = extractvalue { i64, { i64, i1 } } %xva2, 1
    %a1aa1 = extractvalue { i64, i1 } %xwa1, 0
    %a2aa1 = extractvalue { i64, i1 } %xwa1, 1
    %a1k1 = extractvalue { i8*, i64 } %x1, 0
    %a2h1 = extractvalue { i8*, i64 } %x1, 1
    %xxa1 = getelementptr i8, i8* %a1k1, i64 %a1j1
    %xya2 = load i8, i8* %xxa1
    %xza1 = icmp ule i8 48, %xya2
    %yaa1 = icmp ule i8 %xya2, 57
    %yba1 = and i1 %xza1, %yaa1
    br i1 %yba1, label %thene, label %elsee

  thene:
    %a1l = extractvalue { i8*, i64 } %x1, 0
    %a2i = extractvalue { i8*, i64 } %x1, 1
    %yca = add i64 %a1j1, 1
    %tmpi = sub i8 %xya2, 48
    %yda = zext i8 %tmpi to i64
    %yea = mul i64 10, %a1aa1
    %yfa1 = add i64 %yea, %yda
    %ygaa = insertvalue { i64, { i64, i1 } } zeroinitializer, i64 %yca, 0
    %yva = insertvalue { i64, i1 } zeroinitializer, i64 %yfa1, 0
    %tmpla = insertvalue { i64, i1 } %yva, i1 %a2aa1, 1
    %x12 = insertvalue { i64, { i64, i1 } } %ygaa, { i64, i1 } %tmpla, 1
    br label %ctd_ife

  elsee:
    %yca1 = insertvalue { i64, { i64, i1 } } zeroinitializer, i64 %a1j1, 0
    %yra = insertvalue { i64, i1 } zeroinitializer, i64 %a1aa1, 0
    %tmpka = insertvalue { i64, i1 } %yra, i1 1, 1
    %x13 = insertvalue { i64, { i64, i1 } } %yca1, { i64, i1 } %tmpka, 1
    br label %ctd_ife

  ctd_ife:
    %x14 = phi { i64, { i64, i1 } } [ %x13, %elsee ], [ %x12, %thene ]
    br label %while_starta

  while_enda:
    %a1j2 = extractvalue { i64, { i64, i1 } } %xva2, 0
    %xwa2 = extractvalue { i64, { i64, i1 } } %xva2, 1
    %a1aa2 = extractvalue { i64, i1 } %xwa2, 0
    %a2aa2 = extractvalue { i64, i1 } %xwa2, 1
    %xxa2 = icmp slt i64 2147483647, %a1aa2
    %yna = insertvalue { i64, i1 } zeroinitializer, i64 %a1aa2, 0
    %tmpia = insertvalue { i64, i1 } %yna, i1 %xxa2, 1
    %a1ba = extractvalue { i64, i1 } %tmpia, 0
    %ypa = insertvalue { i64, i1 } zeroinitializer, i64 %a1aa2, 0
    %tmpja = insertvalue { i64, i1 } %ypa, i1 %xxa2, 1
    %a2ba = extractvalue { i64, i1 } %tmpja, 1
    br i1 %a2ba, label %thenf, label %elsef

  thenf:
    %xya3 = trunc i64 1 to i32
    %yra1 = insertvalue { i32, i1 } zeroinitializer, i32 %xya3, 0
    %tmpaa = insertvalue { i32, i1 } %yra1, i1 %a2ba, 1
    %xza2 = insertvalue { { i32, i1 }, i64 } zeroinitializer, { i32, i1 } %tmpaa, 0
    %x15 = insertvalue { { i32, i1 }, i64 } %xza2, i64 %a1j2, 1
    br label %ctd_iff

  elsef:
    %xya4 = trunc i64 %a1ba to i32
    %yra2 = insertvalue { i32, i1 } zeroinitializer, i32 %xya4, 0
    %tmpaa1 = insertvalue { i32, i1 } %yra2, i1 %a2ba, 1
    %xza3 = insertvalue { { i32, i1 }, i64 } zeroinitializer, { i32, i1 } %tmpaa1, 0
    %x16 = insertvalue { { i32, i1 }, i64 } %xza3, i64 %a1j2, 1
    br label %ctd_iff

  ctd_iff:
    %x17 = phi { { i32, i1 }, i64 } [ %x16, %elsef ], [ %x15, %thenf ]
    br label %ctd_ifd

  ctd_ifd:
    %xua3 = phi { { i32, i1 }, i64 } [ %x17, %ctd_iff ], [ %x9, %thend ]
    %a1aa3 = extractvalue { { i32, i1 }, i64 } %xua3, 0
    %a2aa3 = extractvalue { { i32, i1 }, i64 } %xua3, 1
    %a1ba1 = extractvalue { i32, i1 } %a1aa3, 0
    %a2ba1 = extractvalue { i32, i1 } %a1aa3, 1
    br i1 %a1f1, label %theng, label %elseg

  theng:
    %xva4 = mul i32 2, %a1ba1
    %x18 = add i32 %xva4, 1
    br label %ctd_ifg

  elseg:
    %x19 = mul i32 2, %a1ba1
    br label %ctd_ifg

  ctd_ifg:
    %xva5 = phi i32 [ %x19, %elseg ], [ %x18, %theng ]
    %yja = insertvalue { i32, i1 } zeroinitializer, i32 %xva5, 0
    %tmpaa2 = insertvalue { i32, i1 } %yja, i1 %a2ba1, 1
    %xwa3 = insertvalue { { i32, i1 }, i64 } zeroinitializer, { i32, i1 } %tmpaa2, 0
    %x20 = insertvalue { { i32, i1 }, i64 } %xwa3, i64 %a2aa3, 1
    br label %ctd_ifc

  ctd_ifc:
    %xna2 = phi { { i32, i1 }, i64 } [ %x20, %ctd_ifg ], [ %x8, %thenc ]
    %a1ca = extractvalue { { i32, i1 }, i64 } %xna2, 0
    %a2ca = extractvalue { { i32, i1 }, i64 } %xna2, 1
    %a1da = extractvalue { i32, i1 } %a1ca, 0
    %a2da = extractvalue { i32, i1 } %a1ca, 1
    %a1h1 = extractvalue { i8*, i64 } %x1, 0
    %a2f1 = extractvalue { i8*, i64 } %x1, 1
    %xoa3 = sub i64 %a2f1, %a2ca
    %xpa3 = icmp eq i64 %xoa3, 0
    br i1 %xpa3, label %thenh, label %elseh

  thenh:
    %xqa1 = insertvalue { i1, i64 } zeroinitializer, i1 1, 0
    %x21 = insertvalue { i1, i64 } %xqa1, i64 %a2ca, 1
    br label %ctd_ifh

  elseh:
    %a1i1 = extractvalue { i8*, i64 } %x1, 0
    %a2g1 = extractvalue { i8*, i64 } %x1, 1
    %xqa2 = getelementptr i8, i8* %a1i1, i64 %a2ca
    %xra1 = load i8, i8* %xqa2
    %a1j3 = extractvalue { i8*, i64 } %x1, 0
    %a2h2 = extractvalue { i8*, i64 } %x1, 1
    %xsa1 = add i64 %a2ca, 1
    %xta1 = icmp eq i8 %xra1, 32
    %xua4 = icmp ule i8 9, %xra1
    %xva6 = icmp ule i8 %xra1, 13
    %xwa4 = and i1 %xua4, %xva6
    %xxa3 = or i1 %xta1, %xwa4
    br i1 %xxa3, label %theni, label %elsei

  theni:
    %yma = insertvalue { i64, i1 } zeroinitializer, i64 %xsa1, 0
    %yna1 = insertvalue { i64, i1 } %yma, i1 0, 1
    br label %while_startb

  while_startb:
    %xya5 = phi { i64, i1 } [ %x26, %ctd_ifj ], [ %yna1, %theni ]
    %a1k2 = extractvalue { i64, i1 } %xya5, 0
    %a2i1 = extractvalue { i64, i1 } %xya5, 1
    %xza4 = add i1 %a2i1, 1
    %a1l1 = extractvalue { i8*, i64 } %x1, 0
    %a2j = extractvalue { i8*, i64 } %x1, 1
    %yaa2 = sub i64 %a2j, %a1k2
    %yba2 = icmp eq i64 %yaa2, 0
    %x22 = add i1 %yba2, 1
    %x23 = and i1 %xza4, %x22
    br i1 %x23, label %while_bodyb, label %while_endb

  while_bodyb:
    %a1k3 = extractvalue { i64, i1 } %xya5, 0
    %a2i2 = extractvalue { i64, i1 } %xya5, 1
    %a1l2 = extractvalue { i8*, i64 } %x1, 0
    %a2j1 = extractvalue { i8*, i64 } %x1, 1
    %xza5 = getelementptr i8, i8* %a1l2, i64 %a1k3
    %yaa3 = load i8, i8* %xza5
    %yba3 = icmp eq i8 %yaa3, 32
    %yca2 = icmp ule i8 9, %yaa3
    %yda1 = icmp ule i8 %yaa3, 13
    %yea1 = and i1 %yca2, %yda1
    %yfa2 = or i1 %yba3, %yea1
    br i1 %yfa2, label %thenj, label %elsej

  thenj:
    %a1m = extractvalue { i8*, i64 } %x1, 0
    %a2k = extractvalue { i8*, i64 } %x1, 1
    %yga1 = add i64 %a1k3, 1
    %yha1 = insertvalue { i64, i1 } zeroinitializer, i64 %yga1, 0
    %x24 = insertvalue { i64, i1 } %yha1, i1 0, 1
    br label %ctd_ifj

  elsej:
    %yga2 = insertvalue { i64, i1 } zeroinitializer, i64 %a1k3, 0
    %x25 = insertvalue { i64, i1 } %yga2, i1 1, 1
    br label %ctd_ifj

  ctd_ifj:
    %x26 = phi { i64, i1 } [ %x25, %elsej ], [ %x24, %thenj ]
    br label %while_startb

  while_endb:
    %a1k4 = extractvalue { i64, i1 } %xya5, 0
    %a2i3 = extractvalue { i64, i1 } %xya5, 1
    %xza6 = insertvalue { i1, i64 } zeroinitializer, i1 0, 0
    %x27 = insertvalue { i1, i64 } %xza6, i64 %a1k4, 1
    br label %ctd_ifi

  elsei:
    %xya7 = insertvalue { i1, i64 } zeroinitializer, i1 1, 0
    %x28 = insertvalue { i1, i64 } %xya7, i64 %xsa1, 1
    br label %ctd_ifi

  ctd_ifi:
    %x29 = phi { i1, i64 } [ %x28, %elsei ], [ %x27, %while_endb ]
    br label %ctd_ifh

  ctd_ifh:
    %xqa3 = phi { i1, i64 } [ %x29, %ctd_ifi ], [ %x21, %thenh ]
    %a1ea = extractvalue { i1, i64 } %xqa3, 0
    %a2ea = extractvalue { i1, i64 } %xqa3, 1
    %xra2 = or i1 %a2da, %a1ea
    br i1 %xra2, label %thenk, label %elsek

  thenk:
    %xsa2 = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } zeroinitializer, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %a11, 0
    %yia1 = insertvalue { i1, i1 } zeroinitializer, i1 1, 0
    %tmpfa2 = insertvalue { i1, i1 } %yia1, i1 1, 1
    %yja1 = insertvalue { i64, { i1, i1 } } zeroinitializer, i64 %a2ea, 0
    %tmpga3 = insertvalue { i64, { i1, i1 } } %yja1, { i1, i1 } %tmpfa2, 1
    %x30 = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } %xsa2, { i64, { i1, i1 } } %tmpga3, 1
    br label %ctd_ifk

  elsek:
    %xsa3 = call { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } @CNF_Parser_Impl_builder_add_lit_impl (i32 %a1da, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %a11)
    %xta2 = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } zeroinitializer, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %xsa3, 0
    %yia2 = insertvalue { i1, i1 } zeroinitializer, i1 0, 0
    %tmpfa3 = insertvalue { i1, i1 } %yia2, i1 0, 1
    %yja2 = insertvalue { i64, { i1, i1 } } zeroinitializer, i64 %a2ea, 0
    %tmpga4 = insertvalue { i64, { i1, i1 } } %yja2, { i1, i1 } %tmpfa3, 1
    %x31 = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } %xta2, { i64, { i1, i1 } } %tmpga4, 1
    br label %ctd_ifk

  ctd_ifk:
    %x32 = phi { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } [ %x31, %elsek ], [ %x30, %thenk ]
    br label %ctd_ifa

  ctd_ifa:
    %x33 = phi { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } [ %x32, %ctd_ifk ], [ %x5, %thena ]
    br label %ctd_if

  ctd_if:
    %x34 = phi { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } [ %x33, %ctd_ifa ], [ %x4, %then ]
    br label %while_start

  while_end:
    %a12 = extractvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } %xda, 0
    %xaaa2 = extractvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } %xda, 1
    %a1a2 = extractvalue { i64, { i1, i1 } } %xaaa2, 0
    %xbaa2 = extractvalue { i64, { i1, i1 } } %xaaa2, 1
    %a1b2 = extractvalue { i1, i1 } %xbaa2, 0
    %a2b2 = extractvalue { i1, i1 } %xbaa2, 1
    %xka3 = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 } zeroinitializer, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %a12, 0
    %tmpaa3 = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 } %xka3, i1 %a1b2, 1
    %xcaa1 = insertvalue { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } zeroinitializer, { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 } %tmpaa3, 0
    %x35 = insertvalue { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } %xcaa1, i64 %a1a2, 1
    ret { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } %x35
}

define { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } @CNF_Parser_Impl_parse_dimacs2_impl(i64 %x, { i8*, i64 } %x1, i64 %x2) #0 {

  start:
    %x3 = call { i1, i64 } @CNF_Parser_Impl_parse_comments_impl ({ i8*, i64 } %x1, i64 %x2)
    %a1 = extractvalue { i1, i64 } %x3, 0
    %a2 = extractvalue { i1, i64 } %x3, 1
    %xaa = call { i1, i64 } @CNF_Parser_Impl_parse_maybe_p_header_impl ({ i8*, i64 } %x1, i64 %a2)
    %a1a = extractvalue { i1, i64 } %xaa, 0
    %a2a = extractvalue { i1, i64 } %xaa, 1
    %xba = call { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } @CNF_Parser_Impl_parse_cnf_aux_formula2_impl (i64 %x, { i8*, i64 } %x1, i64 %a2a)
    %a1b = extractvalue { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } %xba, 0
    %a2b = extractvalue { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } %xba, 1
    %a1c = extractvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 } %a1b, 0
    %a2c = extractvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 } %a1b, 1
    %a1d = extractvalue { i8*, i64 } %x1, 0
    %a2d = extractvalue { i8*, i64 } %x1, 1
    %xca = sub i64 %a2d, %a2b
    %xda = icmp eq i64 %xca, 0
    %xea = add i1 %xda, 1
    %xfa = or i1 %a2c, %xea
    %xga = or i1 %a1a, %xfa
    %xha = or i1 %a1, %xga
    %xma = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 } zeroinitializer, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %a1c, 0
    %tmpaa = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 } %xma, i1 %xha, 1
    %xia = insertvalue { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } zeroinitializer, { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 } %tmpaa, 0
    %x4 = insertvalue { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } %xia, i64 %a2b, 1
    ret { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } %x4
}

define { i1, i64 } @CNF_Parser_Impl_parse_skip_to_impl(i8 %x, { i8*, i64 } %x1, i64 %x2) #0 {

  start:
    %xa = insertvalue { i1, i1 } zeroinitializer, i1 0, 0
    %tmpba = insertvalue { i1, i1 } %xa, i1 0, 1
    %xaa = insertvalue { i64, { i1, i1 } } zeroinitializer, i64 %x2, 0
    %xba = insertvalue { i64, { i1, i1 } } %xaa, { i1, i1 } %tmpba, 1
    br label %while_start

  while_start:
    %xca = phi { i64, { i1, i1 } } [ %x8, %ctd_if ], [ %xba, %start ]
    %a1 = extractvalue { i64, { i1, i1 } } %xca, 0
    %xaaa = extractvalue { i64, { i1, i1 } } %xca, 1
    %a1a = extractvalue { i1, i1 } %xaaa, 0
    %a2a = extractvalue { i1, i1 } %xaaa, 1
    %x3 = add i1 %a1a, 1
    br i1 %x3, label %while_body, label %while_end

  while_body:
    %a11 = extractvalue { i64, { i1, i1 } } %xca, 0
    %xaaa1 = extractvalue { i64, { i1, i1 } } %xca, 1
    %a1a1 = extractvalue { i1, i1 } %xaaa1, 0
    %a2a1 = extractvalue { i1, i1 } %xaaa1, 1
    %a1b = extractvalue { i8*, i64 } %x1, 0
    %a2 = extractvalue { i8*, i64 } %x1, 1
    %xbaa = sub i64 %a2, %a11
    %xcaa = icmp eq i64 %xbaa, 0
    br i1 %xcaa, label %then, label %else

  then:
    %xdaa = insertvalue { i64, { i1, i1 } } zeroinitializer, i64 %a11, 0
    %xla = insertvalue { i1, i1 } zeroinitializer, i1 1, 0
    %tmpea = insertvalue { i1, i1 } %xla, i1 1, 1
    %x4 = insertvalue { i64, { i1, i1 } } %xdaa, { i1, i1 } %tmpea, 1
    br label %ctd_if

  else:
    %a1c = extractvalue { i8*, i64 } %x1, 0
    %a2b = extractvalue { i8*, i64 } %x1, 1
    %xdaa1 = getelementptr i8, i8* %a1c, i64 %a11
    %xea = load i8, i8* %xdaa1
    %a1d = extractvalue { i8*, i64 } %x1, 0
    %a2c = extractvalue { i8*, i64 } %x1, 1
    %xfa = add i64 %a11, 1
    %xga = icmp eq i8 %xea, %x
    br i1 %xga, label %thena, label %elsea

  thena:
    %xha = insertvalue { i64, { i1, i1 } } zeroinitializer, i64 %xfa, 0
    %xqa = insertvalue { i1, i1 } zeroinitializer, i1 1, 0
    %tmpea1 = insertvalue { i1, i1 } %xqa, i1 0, 1
    %x5 = insertvalue { i64, { i1, i1 } } %xha, { i1, i1 } %tmpea1, 1
    br label %ctd_ifa

  elsea:
    %xha1 = insertvalue { i64, { i1, i1 } } zeroinitializer, i64 %xfa, 0
    %xqa1 = insertvalue { i1, i1 } zeroinitializer, i1 0, 0
    %tmpea2 = insertvalue { i1, i1 } %xqa1, i1 0, 1
    %x6 = insertvalue { i64, { i1, i1 } } %xha1, { i1, i1 } %tmpea2, 1
    br label %ctd_ifa

  ctd_ifa:
    %x7 = phi { i64, { i1, i1 } } [ %x6, %elsea ], [ %x5, %thena ]
    br label %ctd_if

  ctd_if:
    %x8 = phi { i64, { i1, i1 } } [ %x7, %ctd_ifa ], [ %x4, %then ]
    br label %while_start

  while_end:
    %a12 = extractvalue { i64, { i1, i1 } } %xca, 0
    %xaaa2 = extractvalue { i64, { i1, i1 } } %xca, 1
    %a1a2 = extractvalue { i1, i1 } %xaaa2, 0
    %a2a2 = extractvalue { i1, i1 } %xaaa2, 1
    %xbaa1 = insertvalue { i1, i64 } zeroinitializer, i1 %a2a2, 0
    %x9 = insertvalue { i1, i64 } %xbaa1, i64 %a12, 1
    ret { i1, i64 } %x9
}

define { i64, i32** } @DS_Clause_Database_cdb_delete_impl(i64 %x, { i64, i32** } %x1) #0 {

  start:
    %a1 = extractvalue { i64, i32** } %x1, 0
    %a2 = extractvalue { i64, i32** } %x1, 1
    %xb = icmp slt i64 %x, %a1
    br i1 %xb, label %then, label %else

  then:
    %xaa = getelementptr i32*, i32** %a2, i64 %x
    %r = load i32*, i32** %xaa
    %p = getelementptr i32*, i32** %a2, i64 %x
    store i32* zeroinitializer, i32** %p
    %xca = insertvalue { i32*, i32** } zeroinitializer, i32* %r, 0
    %xda = insertvalue { i32*, i32** } %xca, i32** %a2, 1
    %c_1 = extractvalue { i32*, i32** } %xda, 0
    %c_2 = extractvalue { i32*, i32** } %xda, 1
    %a = ptrtoint i32* null to i64
    %b = ptrtoint i32* %c_1 to i64
    %d = icmp eq i64 %a, %b
    br i1 %d, label %thena, label %elsea

  thena:
    br label %ctd_ifa

  elsea:
    call void @DS_Clause_zcl_free_impl (i32* %c_1)
    br label %ctd_ifa

  ctd_ifa:
    %a1a = extractvalue { i32*, i32** } %xda, 0
    %ba = extractvalue { i32*, i32** } %xda, 1
    %xea = insertvalue { i64, i32** } zeroinitializer, i64 %a1, 0
    %x2 = insertvalue { i64, i32** } %xea, i32** %ba, 1
    br label %ctd_if

  else:
    %xaa1 = insertvalue { i64, i32** } zeroinitializer, i64 %a1, 0
    %x3 = insertvalue { i64, i32** } %xaa1, i32** %a2, 1
    br label %ctd_if

  ctd_if:
    %x4 = phi { i64, i32** } [ %x3, %else ], [ %x2, %ctd_ifa ]
    ret { i64, i32** } %x4
}

define { i64, i32** } @DS_Clause_Database_cdb_insert_impl(i64 %x, i32* %x1, { i64, i32** } %x2) #0 {

  start:
    %a1 = extractvalue { i64, i32** } %x2, 0
    %a2 = extractvalue { i64, i32** } %x2, 1
    %xb = icmp slt i64 %x, %a1
    br i1 %xb, label %then, label %else

  then:
    %xaa = insertvalue { i64, i32** } zeroinitializer, i64 %a1, 0
    %x3 = insertvalue { i64, i32** } %xaa, i32** %a2, 1
    br label %ctd_if

  else:
    %r = sub i64 0, 1
    %xaa1 = lshr i64 %r, 1
    %xba = udiv i64 %xaa1, 2
    %xca = icmp sle i64 %xba, %a1
    br i1 %xca, label %thena, label %elsea

  thena:
    %xda = add i64 %x, 1
    %xea = call i32** @LRAT_Sepref_Base_wo_grow_impl (i64 %a1, i32** %a2, i64 %xda)
    %xfa = insertvalue { i64, i32** } zeroinitializer, i64 %xda, 0
    %x4 = insertvalue { i64, i32** } %xfa, i32** %xea, 1
    br label %ctd_ifa

  elsea:
    %xda1 = mul i64 2, %a1
    %xea1 = add i64 %x, 1
    %xfa1 = icmp sle i64 %xda1, %xea1
    br i1 %xfa1, label %thenb, label %elseb

  thenb:
    %x5 = add i64 %x, 1
    br label %ctd_ifb

  elseb:
    %x6 = mul i64 2, %a1
    br label %ctd_ifb

  ctd_ifb:
    %xg = phi i64 [ %x6, %elseb ], [ %x5, %thenb ]
    %xh = call i32** @LRAT_Sepref_Base_wo_grow_impl (i64 %a1, i32** %a2, i64 %xg)
    %xia = insertvalue { i64, i32** } zeroinitializer, i64 %xg, 0
    %x7 = insertvalue { i64, i32** } %xia, i32** %xh, 1
    br label %ctd_ifa

  ctd_ifa:
    %x8 = phi { i64, i32** } [ %x7, %ctd_ifb ], [ %x4, %thena ]
    br label %ctd_if

  ctd_if:
    %xaa2 = phi { i64, i32** } [ %x8, %ctd_ifa ], [ %x3, %then ]
    %a1a = extractvalue { i64, i32** } %xaa2, 0
    %a2a = extractvalue { i64, i32** } %xaa2, 1
    %xba1 = getelementptr i32*, i32** %a2a, i64 %x
    %r1 = load i32*, i32** %xba1
    %p = getelementptr i32*, i32** %a2a, i64 %x
    store i32* %x1, i32** %p
    %xda2 = insertvalue { i32*, i32** } zeroinitializer, i32* %r1, 0
    %xea2 = insertvalue { i32*, i32** } %xda2, i32** %a2a, 1
    %c_1 = extractvalue { i32*, i32** } %xea2, 0
    %c_2 = extractvalue { i32*, i32** } %xea2, 1
    %a = ptrtoint i32* null to i64
    %b = ptrtoint i32* %c_1 to i64
    %d = icmp eq i64 %a, %b
    br i1 %d, label %thenc, label %elsec

  thenc:
    br label %ctd_ifc

  elsec:
    call void @DS_Clause_zcl_free_impl (i32* %c_1)
    br label %ctd_ifc

  ctd_ifc:
    %a1b = extractvalue { i32*, i32** } %xea2, 0
    %ba = extractvalue { i32*, i32** } %xea2, 1
    %xfa2 = insertvalue { i64, i32** } zeroinitializer, i64 %a1a, 0
    %x9 = insertvalue { i64, i32** } %xfa2, i32** %ba, 1
    ret { i64, i32** } %x9
}

define void @DS_Reversible_Assignment_rpan_free({ { i64, i1* }, { i64, { i64, i32* } } } %x) #0 {

  start:
    %a = extractvalue { { i64, i1* }, { i64, { i64, i32* } } } %x, 0
    %b = extractvalue { { i64, i1* }, { i64, { i64, i32* } } } %x, 1
    %xc = insertvalue { { i64, i1* }, { { i64, { i64, i32* } }, i1 } } zeroinitializer, { i64, i1* } %a, 0
    %xd = insertvalue { { i64, { i64, i32* } }, i1 } zeroinitializer, { i64, { i64, i32* } } %b, 0
    %tmpb = insertvalue { { i64, { i64, i32* } }, i1 } %xd, i1 zeroinitializer, 1
    %tmpc = insertvalue { { i64, i1* }, { { i64, { i64, i32* } }, i1 } } %xc, { { i64, { i64, i32* } }, i1 } %tmpb, 1
    %c_1 = extractvalue { { i64, i1* }, { { i64, { i64, i32* } }, i1 } } %tmpc, 0
    %aa = extractvalue { { i64, i1* }, { i64, { i64, i32* } } } %x, 0
    %ba = extractvalue { { i64, i1* }, { i64, { i64, i32* } } } %x, 1
    %xba = insertvalue { { i64, i1* }, { { i64, { i64, i32* } }, i1 } } zeroinitializer, { i64, i1* } %aa, 0
    %xj = insertvalue { { i64, { i64, i32* } }, i1 } zeroinitializer, { i64, { i64, i32* } } %ba, 0
    %tmpac = insertvalue { { i64, { i64, i32* } }, i1 } %xj, i1 zeroinitializer, 1
    %tmpad = insertvalue { { i64, i1* }, { { i64, { i64, i32* } }, i1 } } %xba, { { i64, { i64, i32* } }, i1 } %tmpac, 1
    %c_2 = extractvalue { { i64, i1* }, { { i64, { i64, i32* } }, i1 } } %tmpad, 1
    %a1 = extractvalue { i64, i1* } %c_1, 0
    %xfa = extractvalue { i64, i1* } %c_1, 1
    call void @LLVM_DS_NArray_narray_free2 (i1* %xfa)
    %c_11 = extractvalue { { i64, { i64, i32* } }, i1 } %c_2, 0
    %c_21 = extractvalue { { i64, { i64, i32* } }, i1 } %c_2, 1
    %uua = extractvalue { i64, { i64, i32* } } %c_11, 0
    %xaaa = extractvalue { i64, { i64, i32* } } %c_11, 1
    %uub = extractvalue { i64, i32* } %xaaa, 0
    %xbaa = extractvalue { i64, i32* } %xaaa, 1
    call void @LLVM_DS_NArray_narray_free (i32* %xbaa)
    ret void
}

define { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } @LRAT_Checker_Impl_add_literal_impl(i32 %x, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %x1) #0 {

  start:
    %a1 = extractvalue { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %x1, 0
    %xb = extractvalue { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %x1, 1
    %a1a = extractvalue { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %xb, 0
    %xaa = extractvalue { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %xb, 1
    %a1b = extractvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %xaa, 0
    %a2b = extractvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %xaa, 1
    %xba = call { i32, { i64, { i64, i32* } } } @DS_Clause_Builder_cbld_add_lit_impl (i32 %x, { i32, { i64, { i64, i32* } } } %a1b)
    %xca = xor i32 %x, 1
    %a = extractvalue { { i64, i1* }, { i64, { i64, i32* } } } %a1a, 0
    %b = extractvalue { { i64, i1* }, { i64, { i64, i32* } } } %a1a, 1
    %xha = insertvalue { { i64, i1* }, { { i64, { i64, i32* } }, i1 } } zeroinitializer, { i64, i1* } %a, 0
    %xka = insertvalue { { i64, { i64, i32* } }, i1 } zeroinitializer, { i64, { i64, i32* } } %b, 0
    %tmpba = insertvalue { { i64, { i64, i32* } }, i1 } %xka, i1 zeroinitializer, 1
    %tmpc = insertvalue { { i64, i1* }, { { i64, { i64, i32* } }, i1 } } %xha, { { i64, { i64, i32* } }, i1 } %tmpba, 1
    %a1c = extractvalue { { i64, i1* }, { { i64, { i64, i32* } }, i1 } } %tmpc, 0
    %aa = extractvalue { { i64, i1* }, { i64, { i64, i32* } } } %a1a, 0
    %ba = extractvalue { { i64, i1* }, { i64, { i64, i32* } } } %a1a, 1
    %xja = insertvalue { { i64, i1* }, { { i64, { i64, i32* } }, i1 } } zeroinitializer, { i64, i1* } %aa, 0
    %xpa = insertvalue { { i64, { i64, i32* } }, i1 } zeroinitializer, { i64, { i64, i32* } } %ba, 0
    %tmpac = insertvalue { { i64, { i64, i32* } }, i1 } %xpa, i1 zeroinitializer, 1
    %tmpad = insertvalue { { i64, i1* }, { { i64, { i64, i32* } }, i1 } } %xja, { { i64, { i64, i32* } }, i1 } %tmpac, 1
    %xda = extractvalue { { i64, i1* }, { { i64, { i64, i32* } }, i1 } } %tmpad, 1
    %a1aa = extractvalue { { i64, { i64, i32* } }, i1 } %xda, 0
    %a2a = extractvalue { { i64, { i64, i32* } }, i1 } %xda, 1
    %a1d = extractvalue { i64, i1* } %a1c, 0
    %a2 = extractvalue { i64, i1* } %a1c, 1
    %xga = zext i32 %xca to i64
    %xhaa = icmp slt i64 %xga, %a1d
    br i1 %xhaa, label %then, label %else

  then:
    %xiaa = zext i32 %xca to i64
    %a1e = extractvalue { i64, i1* } %a1c, 0
    %a2c = extractvalue { i64, i1* } %a1c, 1
    %p = getelementptr i1, i1* %a2c, i64 %xiaa
    store i1 1, i1* %p
    %xkaaa = insertvalue { i64, i1* } zeroinitializer, i64 %a1e, 0
    %x2 = insertvalue { i64, i1* } %xkaaa, i1* %a2c, 1
    br label %ctd_if

  else:
    %x3 = call { i64, i1* } @DS_Reversible_Assignment_bla_set_checked_aux_impl ({ i64, i1* } %a1c, i32 %xca, i1 1)
    br label %ctd_if

  ctd_if:
    %xiaa1 = phi { i64, i1* } [ %x3, %else ], [ %x2, %then ]
    %l = extractvalue { i64, { i64, i32* } } %a1aa, 0
    %xjaa = extractvalue { i64, { i64, i32* } } %a1aa, 1
    %c = extractvalue { i64, i32* } %xjaa, 0
    %ab = extractvalue { i64, i32* } %xjaa, 1
    %lb = add i64 %l, 1
    %lc = extractvalue { i64, { i64, i32* } } %a1aa, 0
    %xkaaa1 = extractvalue { i64, { i64, i32* } } %a1aa, 1
    %ca = extractvalue { i64, i32* } %xkaaa1, 0
    %aaa = extractvalue { i64, i32* } %xkaaa1, 1
    %cok = icmp sle i64 %lb, %ca
    br i1 %cok, label %thena, label %elsea

  thena:
    %xlaaa = insertvalue { i64, { i64, i32* } } zeroinitializer, i64 %lc, 0
    %xza = insertvalue { i64, i32* } zeroinitializer, i64 %ca, 0
    %tmpcb = insertvalue { i64, i32* } %xza, i32* %aaa, 1
    %x4 = insertvalue { i64, { i64, i32* } } %xlaaa, { i64, i32* } %tmpcb, 1
    br label %ctd_ifa

  elsea:
    %xya = insertvalue { i64, i32* } zeroinitializer, i64 %ca, 0
    %tmpbb = insertvalue { i64, i32* } %xya, i32* %aaa, 1
    %xza1 = insertvalue { i64, { i64, i32* } } zeroinitializer, i64 %lc, 0
    %x5 = insertvalue { i64, { i64, i32* } } %xza1, { i64, i32* } %tmpbb, 1
    %x6 = call { i64, { i64, i32* } } @LLVM_DS_Array_List_arl_resize (i64 %lb, { i64, { i64, i32* } } %x5)
    br label %ctd_ifa

  ctd_ifa:
    %al = phi { i64, { i64, i32* } } [ %x6, %elsea ], [ %x4, %thena ]
    %ld = extractvalue { i64, { i64, i32* } } %al, 0
    %xlaaa1 = extractvalue { i64, { i64, i32* } } %al, 1
    %cb = extractvalue { i64, i32* } %xlaaa1, 0
    %aba = extractvalue { i64, i32* } %xlaaa1, 1
    %p1 = getelementptr i32, i32* %aba, i64 %ld
    store i32 %xca, i32* %p1
    %le = add i64 %ld, 1
    %xmaa = insertvalue { i64, { i64, i32* } } zeroinitializer, i64 %le, 0
    %yea = insertvalue { i64, i32* } zeroinitializer, i64 %cb, 0
    %tmpcb1 = insertvalue { i64, i32* } %yea, i32* %aba, 1
    %xnaa = insertvalue { i64, { i64, i32* } } %xmaa, { i64, i32* } %tmpcb1, 1
    %xoaa = insertvalue { { i64, i1* }, { i64, { i64, i32* } } } zeroinitializer, { i64, i1* } %xiaa1, 0
    %xpaaa = insertvalue { { i64, i1* }, { i64, { i64, i32* } } } %xoaa, { i64, { i64, i32* } } %xnaa, 1
    %xqaaa = insertvalue { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } zeroinitializer, i1 %a1, 0
    %yja = insertvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } zeroinitializer, { i32, { i64, { i64, i32* } } } %xba, 0
    %tmpfa = insertvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %yja, { i64, i32** } %a2b, 1
    %yka = insertvalue { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } zeroinitializer, { { i64, i1* }, { i64, { i64, i32* } } } %xpaaa, 0
    %tmpga = insertvalue { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %yka, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %tmpfa, 1
    %x7 = insertvalue { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %xqaaa, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %tmpga, 1
    ret { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %x7
}

define { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } @LRAT_Checker_Impl_start_lemma_impl(i64 %x, { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %x1) #0 {

  start:
    %a1 = extractvalue { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %x1, 0
    %xb = extractvalue { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %x1, 1
    %a1a = extractvalue { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } %xb, 0
    %xaa = extractvalue { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } %xb, 1
    %a1b = extractvalue { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } %xaa, 0
    %xba = extractvalue { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } %xaa, 1
    %a1c = extractvalue { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } %xba, 0
    %a2c = extractvalue { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } %xba, 1
    %xca = call { { i64, i1* }, { i64, { i64, i32* } } } @DS_Reversible_Assignment_rpan_clear_impl (i64 %x, { { i64, i1* }, { i64, { i64, i32* } } } %a2c)
    %xda = insertvalue { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } zeroinitializer, i1 %a1, 0
    %xja = insertvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } zeroinitializer, { i32, { i64, { i64, i32* } } } %a1c, 0
    %tmpaa = insertvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %xja, { i64, i32** } %a1b, 1
    %xka = insertvalue { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } zeroinitializer, { { i64, i1* }, { i64, { i64, i32* } } } %xca, 0
    %tmpba = insertvalue { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %xka, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %tmpaa, 1
    %x2 = insertvalue { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %xda, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %tmpba, 1
    ret { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %x2
}

define { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } @LRAT_Checker_Impl_start_proof_impl({ i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %x) #0 {

  start:
    %a1 = extractvalue { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %x, 0
    %b = extractvalue { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %x, 1
    %a1a = extractvalue { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %b, 0
    %ba = extractvalue { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %b, 1
    %a1b = extractvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %ba, 0
    %a2b = extractvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %ba, 1
    %xg = insertvalue { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } zeroinitializer, i1 %a1, 0
    %xha = insertvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } zeroinitializer, { i32, { i64, { i64, i32* } } } %a1b, 0
    %tmpaa = insertvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %xha, { i64, i32** } %a2b, 1
    %xja = insertvalue { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } zeroinitializer, { { i64, i1* }, { i64, { i64, i32* } } } %a1a, 0
    %tmpab = insertvalue { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %xja, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %tmpaa, 1
    %xka = insertvalue { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } zeroinitializer, i1 0, 0
    %tmpbc = insertvalue { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %xka, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %tmpab, 1
    %x1 = insertvalue { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } %xg, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %tmpbc, 1
    ret { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } %x1
}

define { i1, i64 } @CNF_Parser_Impl_parse_comments_impl({ i8*, i64 } %x, i64 %x1) #0 {

  start:
    %xa = insertvalue { i1, i1 } zeroinitializer, i1 0, 0
    %tmpba = insertvalue { i1, i1 } %xa, i1 0, 1
    %xaa = insertvalue { i64, { i1, i1 } } zeroinitializer, i64 %x1, 0
    %xba = insertvalue { i64, { i1, i1 } } %xaa, { i1, i1 } %tmpba, 1
    br label %while_start

  while_start:
    %xca = phi { i64, { i1, i1 } } [ %x17, %ctd_if ], [ %xba, %start ]
    %a1 = extractvalue { i64, { i1, i1 } } %xca, 0
    %xaaa = extractvalue { i64, { i1, i1 } } %xca, 1
    %a1a = extractvalue { i1, i1 } %xaaa, 0
    %a2a = extractvalue { i1, i1 } %xaaa, 1
    %xbaa = add i1 %a2a, 1
    %a1b = extractvalue { i8*, i64 } %x, 0
    %a2 = extractvalue { i8*, i64 } %x, 1
    %xcaa = sub i64 %a2, %a1
    %xdaa = icmp eq i64 %xcaa, 0
    %x2 = add i1 %xdaa, 1
    %x3 = and i1 %xbaa, %x2
    br i1 %x3, label %while_body, label %while_end

  while_body:
    %a11 = extractvalue { i64, { i1, i1 } } %xca, 0
    %xaaa1 = extractvalue { i64, { i1, i1 } } %xca, 1
    %a1a1 = extractvalue { i1, i1 } %xaaa1, 0
    %a2a1 = extractvalue { i1, i1 } %xaaa1, 1
    %a1b1 = extractvalue { i8*, i64 } %x, 0
    %a21 = extractvalue { i8*, i64 } %x, 1
    %xbaa1 = getelementptr i8, i8* %a1b1, i64 %a11
    %xcaa1 = load i8, i8* %xbaa1
    %xdaa1 = icmp eq i8 %xcaa1, 32
    %xea = icmp ule i8 9, %xcaa1
    %xfa = icmp ule i8 %xcaa1, 13
    %xga = and i1 %xea, %xfa
    %xha = or i1 %xdaa1, %xga
    br i1 %xha, label %then, label %else

  then:
    %a1c = extractvalue { i8*, i64 } %x, 0
    %a2b = extractvalue { i8*, i64 } %x, 1
    %xia = sub i64 %a2b, %a11
    %xja = icmp eq i64 %xia, 0
    br i1 %xja, label %thena, label %elsea

  thena:
    %xka = insertvalue { i1, i64 } zeroinitializer, i1 1, 0
    %x4 = insertvalue { i1, i64 } %xka, i64 %a11, 1
    br label %ctd_ifa

  elsea:
    %a1d = extractvalue { i8*, i64 } %x, 0
    %a2c = extractvalue { i8*, i64 } %x, 1
    %xka1 = getelementptr i8, i8* %a1d, i64 %a11
    %xla = load i8, i8* %xka1
    %a1e = extractvalue { i8*, i64 } %x, 0
    %a2d = extractvalue { i8*, i64 } %x, 1
    %xma = add i64 %a11, 1
    %xna = icmp eq i8 %xla, 32
    %xoa = icmp ule i8 9, %xla
    %xpa = icmp ule i8 %xla, 13
    %xqa = and i1 %xoa, %xpa
    %xra = or i1 %xna, %xqa
    br i1 %xra, label %thenb, label %elseb

  thenb:
    %xva = insertvalue { i64, i1 } zeroinitializer, i64 %xma, 0
    %xwa = insertvalue { i64, i1 } %xva, i1 0, 1
    br label %while_starta

  while_starta:
    %xsa = phi { i64, i1 } [ %x9, %ctd_ifc ], [ %xwa, %thenb ]
    %a1f = extractvalue { i64, i1 } %xsa, 0
    %a2e = extractvalue { i64, i1 } %xsa, 1
    %xta = add i1 %a2e, 1
    %a1g = extractvalue { i8*, i64 } %x, 0
    %a2f = extractvalue { i8*, i64 } %x, 1
    %xua = sub i64 %a2f, %a1f
    %xvaa = icmp eq i64 %xua, 0
    %x5 = add i1 %xvaa, 1
    %x6 = and i1 %xta, %x5
    br i1 %x6, label %while_bodya, label %while_enda

  while_bodya:
    %a1f1 = extractvalue { i64, i1 } %xsa, 0
    %a2e1 = extractvalue { i64, i1 } %xsa, 1
    %a1g1 = extractvalue { i8*, i64 } %x, 0
    %a2f1 = extractvalue { i8*, i64 } %x, 1
    %xta1 = getelementptr i8, i8* %a1g1, i64 %a1f1
    %xua1 = load i8, i8* %xta1
    %xvaa1 = icmp eq i8 %xua1, 32
    %xwaa = icmp ule i8 9, %xua1
    %xxa = icmp ule i8 %xua1, 13
    %xya = and i1 %xwaa, %xxa
    %xza = or i1 %xvaa1, %xya
    br i1 %xza, label %thenc, label %elsec

  thenc:
    %a1h = extractvalue { i8*, i64 } %x, 0
    %a2g = extractvalue { i8*, i64 } %x, 1
    %yaa = add i64 %a1f1, 1
    %yba = insertvalue { i64, i1 } zeroinitializer, i64 %yaa, 0
    %x7 = insertvalue { i64, i1 } %yba, i1 0, 1
    br label %ctd_ifc

  elsec:
    %yaa1 = insertvalue { i64, i1 } zeroinitializer, i64 %a1f1, 0
    %x8 = insertvalue { i64, i1 } %yaa1, i1 1, 1
    br label %ctd_ifc

  ctd_ifc:
    %x9 = phi { i64, i1 } [ %x8, %elsec ], [ %x7, %thenc ]
    br label %while_starta

  while_enda:
    %a1f2 = extractvalue { i64, i1 } %xsa, 0
    %a2e2 = extractvalue { i64, i1 } %xsa, 1
    %xta2 = insertvalue { i1, i64 } zeroinitializer, i1 0, 0
    %x10 = insertvalue { i1, i64 } %xta2, i64 %a1f2, 1
    br label %ctd_ifb

  elseb:
    %xsa2 = insertvalue { i1, i64 } zeroinitializer, i1 1, 0
    %x11 = insertvalue { i1, i64 } %xsa2, i64 %xma, 1
    br label %ctd_ifb

  ctd_ifb:
    %x12 = phi { i1, i64 } [ %x11, %elseb ], [ %x10, %while_enda ]
    br label %ctd_ifa

  ctd_ifa:
    %xka2 = phi { i1, i64 } [ %x12, %ctd_ifb ], [ %x4, %thena ]
    %a1ba = extractvalue { i1, i64 } %xka2, 0
    %a2ba = extractvalue { i1, i64 } %xka2, 1
    %xla1 = insertvalue { i64, { i1, i1 } } zeroinitializer, i64 %a2ba, 0
    %xra1 = insertvalue { i1, i1 } zeroinitializer, i1 %a1ba, 0
    %tmpea = insertvalue { i1, i1 } %xra1, i1 %a1ba, 1
    %x13 = insertvalue { i64, { i1, i1 } } %xla1, { i1, i1 } %tmpea, 1
    br label %ctd_if

  else:
    %xia1 = icmp eq i8 %xcaa1, 99
    br i1 %xia1, label %thend, label %elsed

  thend:
    %xja1 = call { i1, i64 } @CNF_Parser_Impl_parse_skip_block_impl (i8 99, { i8*, i64 } %x, i64 %a11)
    %a1ba1 = extractvalue { i1, i64 } %xja1, 0
    %a2b1 = extractvalue { i1, i64 } %xja1, 1
    %xka3 = insertvalue { i64, { i1, i1 } } zeroinitializer, i64 %a2b1, 0
    %xpa1 = insertvalue { i1, i1 } zeroinitializer, i1 %a1ba1, 0
    %tmpfa = insertvalue { i1, i1 } %xpa1, i1 %a1ba1, 1
    %x14 = insertvalue { i64, { i1, i1 } } %xka3, { i1, i1 } %tmpfa, 1
    br label %ctd_ifd

  elsed:
    %xja2 = insertvalue { i64, { i1, i1 } } zeroinitializer, i64 %a11, 0
    %xna1 = insertvalue { i1, i1 } zeroinitializer, i1 0, 0
    %tmpfa1 = insertvalue { i1, i1 } %xna1, i1 1, 1
    %x15 = insertvalue { i64, { i1, i1 } } %xja2, { i1, i1 } %tmpfa1, 1
    br label %ctd_ifd

  ctd_ifd:
    %x16 = phi { i64, { i1, i1 } } [ %x15, %elsed ], [ %x14, %thend ]
    br label %ctd_if

  ctd_if:
    %x17 = phi { i64, { i1, i1 } } [ %x16, %ctd_ifd ], [ %x13, %ctd_ifa ]
    br label %while_start

  while_end:
    %a12 = extractvalue { i64, { i1, i1 } } %xca, 0
    %xaaa2 = extractvalue { i64, { i1, i1 } } %xca, 1
    %a1a2 = extractvalue { i1, i1 } %xaaa2, 0
    %a2a2 = extractvalue { i1, i1 } %xaaa2, 1
    %xbaa2 = insertvalue { i1, i64 } zeroinitializer, i1 %a1a2, 0
    %x18 = insertvalue { i1, i64 } %xbaa2, i64 %a12, 1
    ret { i1, i64 } %x18
}

define { i32, { i64, { i64, i32* } } } @DS_Clause_Builder_cbld_add_lit_impl(i32 %x, { i32, { i64, { i64, i32* } } } %x1) #0 {

  start:
    %a = extractvalue { i32, { i64, { i64, i32* } } } %x1, 0
    %b = extractvalue { i32, { i64, { i64, i32* } } } %x1, 1
    %xc = insertvalue { i32, { { i64, { i64, i32* } }, i1 } } zeroinitializer, i32 %a, 0
    %xda = insertvalue { { i64, { i64, i32* } }, i1 } zeroinitializer, { i64, { i64, i32* } } %b, 0
    %tmpba = insertvalue { { i64, { i64, i32* } }, i1 } %xda, i1 zeroinitializer, 1
    %tmpc = insertvalue { i32, { { i64, { i64, i32* } }, i1 } } %xc, { { i64, { i64, i32* } }, i1 } %tmpba, 1
    %a1 = extractvalue { i32, { { i64, { i64, i32* } }, i1 } } %tmpc, 0
    %aa = extractvalue { i32, { i64, { i64, i32* } } } %x1, 0
    %ba = extractvalue { i32, { i64, { i64, i32* } } } %x1, 1
    %xba = insertvalue { i32, { { i64, { i64, i32* } }, i1 } } zeroinitializer, i32 %aa, 0
    %xia = insertvalue { { i64, { i64, i32* } }, i1 } zeroinitializer, { i64, { i64, i32* } } %ba, 0
    %tmpac = insertvalue { { i64, { i64, i32* } }, i1 } %xia, i1 zeroinitializer, 1
    %tmpad = insertvalue { i32, { { i64, { i64, i32* } }, i1 } } %xba, { { i64, { i64, i32* } }, i1 } %tmpac, 1
    %xdaa = extractvalue { i32, { { i64, { i64, i32* } }, i1 } } %tmpad, 1
    %a1a = extractvalue { { i64, { i64, i32* } }, i1 } %xdaa, 0
    %a2a = extractvalue { { i64, { i64, i32* } }, i1 } %xdaa, 1
    %xbaa = icmp ule i32 %x, %a1
    br i1 %xbaa, label %then, label %else

  then:
    br label %ctd_if

  else:
    br label %ctd_if

  ctd_if:
    %xcaa = phi i32 [ %x, %else ], [ %a1, %then ]
    %xdaaa = call { i64, { i64, i32* } } @DS_Clause_Buffer_cbuf_insert_impl (i32 %x, { i64, { i64, i32* } } %a1a)
    %xeaaa = insertvalue { i32, { i64, { i64, i32* } } } zeroinitializer, i32 %xcaa, 0
    %x2 = insertvalue { i32, { i64, { i64, i32* } } } %xeaaa, { i64, { i64, i32* } } %xdaaa, 1
    ret { i32, { i64, { i64, i32* } } } %x2
}

define { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } @LRAT_Checker_Impl_finish_proof_impl(i64 %x, { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } %x1) #0 {

  start:
    %a1 = extractvalue { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } %x1, 0
    %xb = extractvalue { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } %x1, 1
    %a1a = extractvalue { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %xb, 0
    %xaa = extractvalue { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %xb, 1
    %a1b = extractvalue { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %xaa, 0
    %xba = extractvalue { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %xaa, 1
    %a1c = extractvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %xba, 0
    %a2c = extractvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %xba, 1
    br i1 %a1, label %then, label %else

  then:
    %xca = call { i32, { i64, { i64, i32* } } } @DS_Clause_Builder_cbld_abort_clause_impl ({ i32, { i64, { i64, i32* } } } %a1c)
    %xda = insertvalue { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } zeroinitializer, i1 %a1, 0
    %xj = insertvalue { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } zeroinitializer, { i32, { i64, { i64, i32* } } } %xca, 0
    %tmpaa = insertvalue { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } %xj, { { i64, i1* }, { i64, { i64, i32* } } } %a1b, 1
    %xk = insertvalue { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } zeroinitializer, { i64, i32** } %a2c, 0
    %tmpab = insertvalue { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } %xk, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } %tmpaa, 1
    %xl = insertvalue { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } zeroinitializer, i1 0, 0
    %tmpb = insertvalue { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } %xl, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } %tmpab, 1
    %x2 = insertvalue { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %xda, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } %tmpb, 1
    br label %ctd_if

  else:
    %xca1 = add i1 %a1a, 1
    br i1 %xca1, label %thena, label %elsea

  thena:
    call void @Debugging_Tools_ll_dbg_tag_err_code_impl (i64 4, i64 0)
    %xea = call { i32, { i64, { i64, i32* } } } @DS_Clause_Builder_cbld_abort_clause_impl ({ i32, { i64, { i64, i32* } } } %a1c)
    %xfa = insertvalue { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } zeroinitializer, i1 1, 0
    %xl1 = insertvalue { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } zeroinitializer, { i32, { i64, { i64, i32* } } } %xea, 0
    %tmpab1 = insertvalue { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } %xl1, { { i64, i1* }, { i64, { i64, i32* } } } %a1b, 1
    %xm = insertvalue { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } zeroinitializer, { i64, i32** } %a2c, 0
    %tmpac = insertvalue { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } %xm, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } %tmpab1, 1
    %xn = insertvalue { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } zeroinitializer, i1 0, 0
    %tmpc = insertvalue { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } %xn, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } %tmpac, 1
    %x3 = insertvalue { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %xfa, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } %tmpc, 1
    br label %ctd_ifa

  elsea:
    %xda1 = call i1 @DS_Clause_Builder_cbld_is_empty_impl ({ i32, { i64, { i64, i32* } } } %a1c)
    %xea1 = call { i32*, { i32, { i64, { i64, i32* } } } } @DS_Clause_Builder_cbld_finish_clause_impl ({ i32, { i64, { i64, i32* } } } %a1c)
    %a1d = extractvalue { i32*, { i32, { i64, { i64, i32* } } } } %xea1, 0
    %a2d = extractvalue { i32*, { i32, { i64, { i64, i32* } } } } %xea1, 1
    %xfa1 = call { i64, i32** } @DS_Clause_Database_cdb_insert_impl (i64 %x, i32* %a1d, { i64, i32** } %a2c)
    %xga = insertvalue { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } zeroinitializer, i1 0, 0
    %xm1 = insertvalue { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } zeroinitializer, { i32, { i64, { i64, i32* } } } %a2d, 0
    %tmpb1 = insertvalue { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } %xm1, { { i64, i1* }, { i64, { i64, i32* } } } %a1b, 1
    %xn1 = insertvalue { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } zeroinitializer, { i64, i32** } %xfa1, 0
    %tmpc1 = insertvalue { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } %xn1, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } %tmpb1, 1
    %xo = insertvalue { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } zeroinitializer, i1 %xda1, 0
    %tmpd = insertvalue { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } %xo, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } %tmpc1, 1
    %x4 = insertvalue { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %xga, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } %tmpd, 1
    br label %ctd_ifa

  ctd_ifa:
    %x5 = phi { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } [ %x4, %elsea ], [ %x3, %thena ]
    br label %ctd_if

  ctd_if:
    %x6 = phi { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } [ %x5, %ctd_ifa ], [ %x2, %then ]
    ret { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %x6
}

define { i8*, i64 } @LRAT_Checker_Impl_mk_rdmem_inp_impl(i8* %x, i64 %x1) #0 {

  start:
    %xa = insertvalue { i8*, i64 } zeroinitializer, i8* %x, 0
    %x2 = insertvalue { i8*, i64 } %xa, i64 %x1, 1
    ret { i8*, i64 } %x2
}

define { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } @CNF_Parser_Impl_builder_add_lit_impl(i32 %x, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %x1) #0 {

  start:
    %a1 = extractvalue { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %x1, 0
    %xb = extractvalue { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %x1, 1
    %a1a = extractvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %xb, 0
    %a2a = extractvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %xb, 1
    %xaa = call { i32, { i64, { i64, i32* } } } @DS_Clause_Builder_cbld_add_lit_impl (i32 %x, { i32, { i64, { i64, i32* } } } %a1a)
    %xba = insertvalue { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } zeroinitializer, i64 %a1, 0
    %xfa = insertvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } zeroinitializer, { i32, { i64, { i64, i32* } } } %xaa, 0
    %tmpaa = insertvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %xfa, { i64, i32** } %a2a, 1
    %x2 = insertvalue { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %xba, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %tmpaa, 1
    ret { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %x2
}

define { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } @CNF_Parser_Impl_parse_cnf_loop2_impl({ i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %x, { i8*, i64 } %x1, i64 %x2) #0 {

  start:
    %xa = insertvalue { i1, i1 } zeroinitializer, i1 0, 0
    %tmpba = insertvalue { i1, i1 } %xa, i1 0, 1
    %xaa = insertvalue { i64, { i1, i1 } } zeroinitializer, i64 %x2, 0
    %tmpca = insertvalue { i64, { i1, i1 } } %xaa, { i1, i1 } %tmpba, 1
    %xba = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } zeroinitializer, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %x, 0
    %xca = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } %xba, { i64, { i1, i1 } } %tmpca, 1
    br label %while_start

  while_start:
    %xda = phi { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } [ %x16, %ctd_if ], [ %xca, %start ]
    %a1 = extractvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } %xda, 0
    %xaaa = extractvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } %xda, 1
    %a1a = extractvalue { i64, { i1, i1 } } %xaaa, 0
    %xbaa = extractvalue { i64, { i1, i1 } } %xaaa, 1
    %a1b = extractvalue { i1, i1 } %xbaa, 0
    %a2b = extractvalue { i1, i1 } %xbaa, 1
    %xcaa = add i1 %a1b, 1
    %a1c = extractvalue { i8*, i64 } %x1, 0
    %a2 = extractvalue { i8*, i64 } %x1, 1
    %xdaa = sub i64 %a2, %a1a
    %xeaa = icmp eq i64 %xdaa, 0
    %x3 = add i1 %xeaa, 1
    %x4 = and i1 %xcaa, %x3
    br i1 %x4, label %while_body, label %while_end

  while_body:
    %a11 = extractvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } %xda, 0
    %xaaa1 = extractvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } %xda, 1
    %a1a1 = extractvalue { i64, { i1, i1 } } %xaaa1, 0
    %xbaa1 = extractvalue { i64, { i1, i1 } } %xaaa1, 1
    %a1b1 = extractvalue { i1, i1 } %xbaa1, 0
    %a2b1 = extractvalue { i1, i1 } %xbaa1, 1
    %a1c1 = extractvalue { i8*, i64 } %x1, 0
    %a21 = extractvalue { i8*, i64 } %x1, 1
    %xcaa1 = getelementptr i8, i8* %a1c1, i64 %a1a1
    %xdaa1 = load i8, i8* %xcaa1
    %a1d = extractvalue { i8*, i64 } %x1, 0
    %a2a = extractvalue { i8*, i64 } %x1, 1
    %xeaa1 = add i64 %a1a1, 1
    %xfaa = icmp eq i8 %xdaa1, 32
    %xga = icmp ule i8 9, %xdaa1
    %xha = icmp ule i8 %xdaa1, 13
    %xia = and i1 %xga, %xha
    %xja = or i1 %xfaa, %xia
    %xka = add i1 %xja, 1
    br i1 %xka, label %then, label %else

  then:
    %xla = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } zeroinitializer, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %a11, 0
    %xta = insertvalue { i1, i1 } zeroinitializer, i1 1, 0
    %tmpga = insertvalue { i1, i1 } %xta, i1 1, 1
    %xua = insertvalue { i64, { i1, i1 } } zeroinitializer, i64 %xeaa1, 0
    %tmpha = insertvalue { i64, { i1, i1 } } %xua, { i1, i1 } %tmpga, 1
    %x5 = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } %xla, { i64, { i1, i1 } } %tmpha, 1
    br label %ctd_if

  else:
    %xsa = insertvalue { i64, i1 } zeroinitializer, i64 %xeaa1, 0
    %xta1 = insertvalue { i64, i1 } %xsa, i1 0, 1
    br label %while_starta

  while_starta:
    %xla1 = phi { i64, i1 } [ %x10, %ctd_ifa ], [ %xta1, %else ]
    %a1e = extractvalue { i64, i1 } %xla1, 0
    %a2c = extractvalue { i64, i1 } %xla1, 1
    %xma = add i1 %a2c, 1
    %a1f = extractvalue { i8*, i64 } %x1, 0
    %a2d = extractvalue { i8*, i64 } %x1, 1
    %xna = sub i64 %a2d, %a1e
    %xoa = icmp eq i64 %xna, 0
    %x6 = add i1 %xoa, 1
    %x7 = and i1 %xma, %x6
    br i1 %x7, label %while_bodya, label %while_enda

  while_bodya:
    %a1e1 = extractvalue { i64, i1 } %xla1, 0
    %a2c1 = extractvalue { i64, i1 } %xla1, 1
    %a1f1 = extractvalue { i8*, i64 } %x1, 0
    %a2d1 = extractvalue { i8*, i64 } %x1, 1
    %xma1 = getelementptr i8, i8* %a1f1, i64 %a1e1
    %xna1 = load i8, i8* %xma1
    %xoa1 = icmp eq i8 %xna1, 32
    %xpa = icmp ule i8 9, %xna1
    %xqa = icmp ule i8 %xna1, 13
    %xra = and i1 %xpa, %xqa
    %xsaa = or i1 %xoa1, %xra
    br i1 %xsaa, label %thena, label %elsea

  thena:
    %a1g = extractvalue { i8*, i64 } %x1, 0
    %a2e = extractvalue { i8*, i64 } %x1, 1
    %xtaa = add i64 %a1e1, 1
    %xua1 = insertvalue { i64, i1 } zeroinitializer, i64 %xtaa, 0
    %x8 = insertvalue { i64, i1 } %xua1, i1 0, 1
    br label %ctd_ifa

  elsea:
    %xtaa1 = insertvalue { i64, i1 } zeroinitializer, i64 %a1e1, 0
    %x9 = insertvalue { i64, i1 } %xtaa1, i1 1, 1
    br label %ctd_ifa

  ctd_ifa:
    %x10 = phi { i64, i1 } [ %x9, %elsea ], [ %x8, %thena ]
    br label %while_starta

  while_enda:
    %a1e2 = extractvalue { i64, i1 } %xla1, 0
    %a2c2 = extractvalue { i64, i1 } %xla1, 1
    %a1f2 = extractvalue { i8*, i64 } %x1, 0
    %a2d2 = extractvalue { i8*, i64 } %x1, 1
    %xma2 = sub i64 %a2d2, %a1e2
    %xna2 = icmp eq i64 %xma2, 0
    br i1 %xna2, label %thenb, label %elseb

  thenb:
    %xoa2 = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } zeroinitializer, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %a11, 0
    %yaa = insertvalue { i1, i1 } zeroinitializer, i1 1, 0
    %tmpha1 = insertvalue { i1, i1 } %yaa, i1 0, 1
    %yba = insertvalue { i64, { i1, i1 } } zeroinitializer, i64 %a1e2, 0
    %tmpia = insertvalue { i64, { i1, i1 } } %yba, { i1, i1 } %tmpha1, 1
    %x11 = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } %xoa2, { i64, { i1, i1 } } %tmpia, 1
    br label %ctd_ifb

  elseb:
    %xoa3 = call { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } @CNF_Parser_Impl_parse_clause2_impl ({ i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %a11, { i8*, i64 } %x1, i64 %a1e2)
    %a1ea = extractvalue { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } %xoa3, 0
    %a2e1 = extractvalue { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } %xoa3, 1
    %a1fa = extractvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 } %a1ea, 0
    %a2f = extractvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 } %a1ea, 1
    br i1 %a2f, label %thenc, label %elsec

  thenc:
    %xpa1 = call { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } @CNF_Parser_Impl_builder_abort_clause_impl ({ i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %a1fa)
    %xqa1 = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } zeroinitializer, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %xpa1, 0
    %yea = insertvalue { i1, i1 } zeroinitializer, i1 1, 0
    %tmpha2 = insertvalue { i1, i1 } %yea, i1 1, 1
    %yfa = insertvalue { i64, { i1, i1 } } zeroinitializer, i64 %a2e1, 0
    %tmpia1 = insertvalue { i64, { i1, i1 } } %yfa, { i1, i1 } %tmpha2, 1
    %x12 = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } %xqa1, { i64, { i1, i1 } } %tmpia1, 1
    br label %ctd_ifc

  elsec:
    %xpa2 = call { i1, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } @CNF_Parser_Impl_builder_finish_clause_impl ({ i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %a1fa)
    %a1g1 = extractvalue { i1, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %xpa2, 0
    %a2g = extractvalue { i1, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %xpa2, 1
    %xqa2 = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } zeroinitializer, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %a2g, 0
    %yga = insertvalue { i1, i1 } zeroinitializer, i1 %a1g1, 0
    %tmpga1 = insertvalue { i1, i1 } %yga, i1 %a1g1, 1
    %yha = insertvalue { i64, { i1, i1 } } zeroinitializer, i64 %a2e1, 0
    %tmpha3 = insertvalue { i64, { i1, i1 } } %yha, { i1, i1 } %tmpga1, 1
    %x13 = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } %xqa2, { i64, { i1, i1 } } %tmpha3, 1
    br label %ctd_ifc

  ctd_ifc:
    %x14 = phi { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } [ %x13, %elsec ], [ %x12, %thenc ]
    br label %ctd_ifb

  ctd_ifb:
    %x15 = phi { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } [ %x14, %ctd_ifc ], [ %x11, %thenb ]
    br label %ctd_if

  ctd_if:
    %x16 = phi { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } [ %x15, %ctd_ifb ], [ %x5, %then ]
    br label %while_start

  while_end:
    %a12 = extractvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } %xda, 0
    %xaaa2 = extractvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, { i1, i1 } } } %xda, 1
    %a1a2 = extractvalue { i64, { i1, i1 } } %xaaa2, 0
    %xbaa2 = extractvalue { i64, { i1, i1 } } %xaaa2, 1
    %a1b2 = extractvalue { i1, i1 } %xbaa2, 0
    %a2b2 = extractvalue { i1, i1 } %xbaa2, 1
    %xka1 = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 } zeroinitializer, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %a12, 0
    %tmpaa = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 } %xka1, i1 %a2b2, 1
    %xcaa2 = insertvalue { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } zeroinitializer, { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 } %tmpaa, 0
    %x17 = insertvalue { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } %xcaa2, i64 %a1a2, 1
    ret { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } %x17
}

define i1 @DS_Clause_Builder_cbld_is_empty_impl({ i32, { i64, { i64, i32* } } } %x) #0 {

  start:
    %a = extractvalue { i32, { i64, { i64, i32* } } } %x, 0
    %b = extractvalue { i32, { i64, { i64, i32* } } } %x, 1
    %xc = insertvalue { i32, { { i64, { i64, i32* } }, i1 } } zeroinitializer, i32 %a, 0
    %xd = insertvalue { { i64, { i64, i32* } }, i1 } zeroinitializer, { i64, { i64, i32* } } %b, 0
    %tmpb = insertvalue { { i64, { i64, i32* } }, i1 } %xd, i1 zeroinitializer, 1
    %tmpc = insertvalue { i32, { { i64, { i64, i32* } }, i1 } } %xc, { { i64, { i64, i32* } }, i1 } %tmpb, 1
    %a1 = extractvalue { i32, { { i64, { i64, i32* } }, i1 } } %tmpc, 0
    %aa = extractvalue { i32, { i64, { i64, i32* } } } %x, 0
    %ba = extractvalue { i32, { i64, { i64, i32* } } } %x, 1
    %xba = insertvalue { i32, { { i64, { i64, i32* } }, i1 } } zeroinitializer, i32 %aa, 0
    %xj = insertvalue { { i64, { i64, i32* } }, i1 } zeroinitializer, { i64, { i64, i32* } } %ba, 0
    %tmpac = insertvalue { { i64, { i64, i32* } }, i1 } %xj, i1 zeroinitializer, 1
    %tmpad = insertvalue { i32, { { i64, { i64, i32* } }, i1 } } %xba, { { i64, { i64, i32* } }, i1 } %tmpac, 1
    %xda = extractvalue { i32, { { i64, { i64, i32* } }, i1 } } %tmpad, 1
    %a1a = extractvalue { { i64, { i64, i32* } }, i1 } %xda, 0
    %a2a = extractvalue { { i64, { i64, i32* } }, i1 } %xda, 1
    %l = extractvalue { i64, { i64, i32* } } %a1a, 0
    %xaaa = extractvalue { i64, { i64, i32* } } %a1a, 1
    %c = extractvalue { i64, i32* } %xaaa, 0
    %ab = extractvalue { i64, i32* } %xaaa, 1
    %xcaa = icmp eq i64 %l, 0
    %xdaa = insertvalue { i32, { i64, { i64, i32* } } } zeroinitializer, i32 %a1, 0
    %xeaa = insertvalue { i32, { i64, { i64, i32* } } } %xdaa, { i64, { i64, i32* } } %a1a, 1
    ret i1 %xcaa
}

define i1 @DS_Clause_Database_cdb_contains_impl(i64 %x, { i64, i32** } %x1) #0 {

  start:
    %a1 = extractvalue { i64, i32** } %x1, 0
    %a2 = extractvalue { i64, i32** } %x1, 1
    %x2 = icmp slt i64 %x, %a1
    br i1 %x2, label %then, label %else

  then:
    %xa = getelementptr i32*, i32** %a2, i64 %x
    %xb = load i32*, i32** %xa
    %a = ptrtoint i32* null to i64
    %b = ptrtoint i32* %xb to i64
    %xc = icmp eq i64 %a, %b
    %x3 = add i1 %xc, 1
    br label %ctd_if

  else:
    br label %ctd_if

  ctd_if:
    %x4 = phi i1 [ 0, %else ], [ %x3, %then ]
    ret i1 %x4
}

define { i32, i1 } @LRAT_Checker_Impl_cdb_check_uot_impl({ { i64, i1* }, { i64, { i64, i32* } } } %x, { i64, i32** } %x1, i64 %x2) #0 {

  start:
    %x3 = call i1 @DS_Clause_Database_cdb_contains_impl (i64 %x2, { i64, i32** } %x1)
    br i1 %x3, label %then, label %else

  then:
    %xb = insertvalue { i32, i1 } zeroinitializer, i32 0, 0
    %y = insertvalue { i32, i1 } %xb, i1 0, 1
    %x4 = call { i32, i1 } @Monadify_M_CONST_DS_Clause_Database_cdb_iterate_clause_impl_MMonad_Mreturn_Num_numeral_class_numeral_Num_num_One_MMonad_Mbind_LLVM_Shallow_ll_extract_value_Groups_zero_class_zero_MMonad_Mbind_LLVM_Shallow_ll_extract_value_Num_numeral_class_numeral_Num_num_One_MMonad_Mbind_LLVM_Shallow_ll_xor_Num_numeral_class_numeral_Num_num_One_MMonad_Mbind_LLVM_Shallow_ll_extract_value_Product_Type_prod_case_prod_Product_Type_Pair_Product_Type_Pair_LLVM_Shallow_llvm_rep_class_init_Groups_zero_class_zero_MMonad_Mbind_LLVM_Shallow_ll_extract_value_Product_Type_prod_case_prod_Product_Type_Pair_Product_Type_Pair_LLVM_Shallow_llvm_rep_class_init_Num_numeral_class_numeral_Num_num_One_MMonad_Mbind_LLVM_Shallow_ll_extract_value_Groups_zero_class_zero_MMonad_Mbind_LLVM_Shallow_ll_extract_value_Num_numeral_class_numeral_Num_num_One_MMonad_Mbind_LLVM_Shallow_ll_zext_Pure_type_MMonad_Mbind_LLVM_Shallow_ll_extract_value_Groups_zero_class_zero_MMonad_Mbind_LLVM_Shallow_ll_extract_value_Num_numeral_class_numeral_Num_num_One_MMonad_Mbind_LLVM_Shallow_ll_ofs_ptr_MMonad_Mbind_LLVM_Shallow_ll_load_LLVM_Shallow_llc_if_MMonad_Mbind_LLVM_Shallow_ll_insert_value_LLVM_Shallow_llvm_rep_class_init_Groups_zero_class_zero_LLVM_Shallow_ll_insert_value_Num_numeral_class_numeral_Num_num_One_MMonad_Mbind_LLVM_Shallow_ll_icmp_eq_Groups_zero_class_zero_LLVM_Shallow_llc_if_MMonad_Mbind_LLVM_Shallow_ll_insert_value_LLVM_Shallow_llvm_rep_class_init_Groups_zero_class_zero_LLVM_Shallow_ll_insert_value_Num_numeral_class_numeral_Num_num_One_MMonad_Mbind_LLVM_Shallow_ll_zext_Pure_type_MMonad_Mbind_Debugging_Tools_ll_dbg_tag_err_code_impl_Num_numeral_class_numeral_Num_num_Bit0_Num_num_One_MMonad_Mbind_LLVM_Shallow_ll_zext_Pure_type_MMonad_Mbind_Debugging_Tools_ll_dbg_tag_err_code_impl_Num_numeral_class_numeral_Num_num_Bit0_Num_num_One_MMonad_Mbind_LLVM_Shallow_ll_insert_value_LLVM_Shallow_llvm_rep_class_init_Groups_zero_class_zero_LLVM_Shallow_ll_insert_value_Num_numeral_class_numeral_Num_num_One_Num_numeral_class_numeral_Num_num_One ({ i64, i32** } %x1, i64 %x2, { { i64, i1* }, { i64, { i64, i32* } } } %x, { i32, i1 } %y)
    br label %ctd_if

  else:
    call void @Debugging_Tools_ll_dbg_tag_err_code_impl (i64 3, i64 %x2)
    %xda = insertvalue { i32, i1 } zeroinitializer, i32 0, 0
    %x5 = insertvalue { i32, i1 } %xda, i1 1, 1
    br label %ctd_if

  ctd_if:
    %x6 = phi { i32, i1 } [ %x5, %else ], [ %x4, %then ]
    ret { i32, i1 } %x6
}

define { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } @LRAT_Checker_Impl_delete_clause_impl(i64 %x, { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %x1) #0 {

  start:
    %a1 = extractvalue { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %x1, 0
    %xb = extractvalue { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %x1, 1
    %a1a = extractvalue { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } %xb, 0
    %xaa = extractvalue { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } %xb, 1
    %a1b = extractvalue { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } %xaa, 0
    %xba = extractvalue { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } %xaa, 1
    %a1c = extractvalue { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } %xba, 0
    %a2c = extractvalue { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } %xba, 1
    %xca = call { i64, i32** } @DS_Clause_Database_cdb_delete_impl (i64 %x, { i64, i32** } %a1b)
    %xda = insertvalue { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } zeroinitializer, i1 %a1, 0
    %xja = insertvalue { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } zeroinitializer, { i32, { i64, { i64, i32* } } } %a1c, 0
    %tmpaa = insertvalue { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } %xja, { { i64, i1* }, { i64, { i64, i32* } } } %a2c, 1
    %xka = insertvalue { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } zeroinitializer, { i64, i32** } %xca, 0
    %tmpba = insertvalue { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } %xka, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } %tmpaa, 1
    %xla = insertvalue { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } zeroinitializer, i1 %a1a, 0
    %tmpca = insertvalue { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } %xla, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } %tmpba, 1
    %x2 = insertvalue { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %xda, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } %tmpca, 1
    ret { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %x2
}

define { i64, { i64, { i64, i8* } } } @LRAT_Parsers_brd_parse_benc_sid_impl({ i64, { i64, i8* } } %x) #0 {

  start:
    %xa = insertvalue { { i64, { i64, i8* } }, i1 } zeroinitializer, { i64, { i64, i8* } } %x, 0
    %tmpba = insertvalue { { i64, { i64, i8* } }, i1 } %xa, i1 0, 1
    %xaa = insertvalue { i64, { { i64, { i64, i8* } }, i1 } } zeroinitializer, i64 0, 0
    %tmpaa = insertvalue { i64, { { i64, { i64, i8* } }, i1 } } %xaa, { { i64, { i64, i8* } }, i1 } %tmpba, 1
    %xba = insertvalue { i64, { i64, { { i64, { i64, i8* } }, i1 } } } zeroinitializer, i64 0, 0
    %xca = insertvalue { i64, { i64, { { i64, { i64, i8* } }, i1 } } } %xba, { i64, { { i64, { i64, i8* } }, i1 } } %tmpaa, 1
    br label %while_start

  while_start:
    %xda = phi { i64, { i64, { { i64, { i64, i8* } }, i1 } } } [ %x5, %ctd_if ], [ %xca, %start ]
    %a1 = extractvalue { i64, { i64, { { i64, { i64, i8* } }, i1 } } } %xda, 0
    %xaaa = extractvalue { i64, { i64, { { i64, { i64, i8* } }, i1 } } } %xda, 1
    %a1a = extractvalue { i64, { { i64, { i64, i8* } }, i1 } } %xaaa, 0
    %xbaa = extractvalue { i64, { { i64, { i64, i8* } }, i1 } } %xaaa, 1
    %a1b = extractvalue { { i64, { i64, i8* } }, i1 } %xbaa, 0
    %a2b = extractvalue { { i64, { i64, i8* } }, i1 } %xbaa, 1
    %xcaa = add i1 %a2b, 1
    %x1 = icmp ult i64 %a1a, 64
    %x2 = and i1 %xcaa, %x1
    br i1 %x2, label %while_body, label %while_end

  while_body:
    %a11 = extractvalue { i64, { i64, { { i64, { i64, i8* } }, i1 } } } %xda, 0
    %xaaa1 = extractvalue { i64, { i64, { { i64, { i64, i8* } }, i1 } } } %xda, 1
    %a1a1 = extractvalue { i64, { { i64, { i64, i8* } }, i1 } } %xaaa1, 0
    %xbaa1 = extractvalue { i64, { { i64, { i64, i8* } }, i1 } } %xaaa1, 1
    %a1b1 = extractvalue { { i64, { i64, i8* } }, i1 } %xbaa1, 0
    %a2b1 = extractvalue { { i64, { i64, i8* } }, i1 } %xbaa1, 1
    %a1c = extractvalue { i64, { i64, i8* } } %a1b1, 0
    %xcaa1 = extractvalue { i64, { i64, i8* } } %a1b1, 1
    %a1aa = extractvalue { i64, i8* } %xcaa1, 0
    %a2a = extractvalue { i64, i8* } %xcaa1, 1
    %xdaa = icmp slt i64 %a1c, %a1aa
    br i1 %xdaa, label %then, label %else

  then:
    %xeaa = getelementptr i8, i8* %a2a, i64 %a1c
    %xfaa = load i8, i8* %xeaa
    %xga = add i64 %a1c, 1
    %xha = insertvalue { i8, { i64, { i64, i8* } } } zeroinitializer, i8 %xfaa, 0
    %xra = insertvalue { i64, i8* } zeroinitializer, i64 %a1aa, 0
    %tmpda = insertvalue { i64, i8* } %xra, i8* %a2a, 1
    %xsa = insertvalue { i64, { i64, i8* } } zeroinitializer, i64 %xga, 0
    %tmpea = insertvalue { i64, { i64, i8* } } %xsa, { i64, i8* } %tmpda, 1
    %x3 = insertvalue { i8, { i64, { i64, i8* } } } %xha, { i64, { i64, i8* } } %tmpea, 1
    br label %ctd_if

  else:
    %x4 = call { i8, { i64, { i64, i8* } } } @LRAT_Parsers_brd_refill_impl (i64 %a1c, i64 %a1aa, i8* %a2a)
    br label %ctd_if

  ctd_if:
    %xeaa1 = phi { i8, { i64, { i64, i8* } } } [ %x4, %else ], [ %x3, %then ]
    %a1ca = extractvalue { i8, { i64, { i64, i8* } } } %xeaa1, 0
    %a2c = extractvalue { i8, { i64, { i64, i8* } } } %xeaa1, 1
    %tmpcc = and i8 %a1ca, 127
    %xfaa1 = zext i8 %tmpcc to i64
    %xga1 = shl i64 %xfaa1, %a1a1
    %xha1 = add i64 %a1a1, 7
    %tmpd = and i8 %a1ca, 128
    %xja = icmp eq i8 %tmpd, 0
    %tmpab = or i64 %a11, %xga1
    %xka = insertvalue { i64, { i64, { { i64, { i64, i8* } }, i1 } } } zeroinitializer, i64 %tmpab, 0
    %xwa = insertvalue { { i64, { i64, i8* } }, i1 } zeroinitializer, { i64, { i64, i8* } } %a2c, 0
    %tmpfa = insertvalue { { i64, { i64, i8* } }, i1 } %xwa, i1 %xja, 1
    %xxa = insertvalue { i64, { { i64, { i64, i8* } }, i1 } } zeroinitializer, i64 %xha1, 0
    %tmpga = insertvalue { i64, { { i64, { i64, i8* } }, i1 } } %xxa, { { i64, { i64, i8* } }, i1 } %tmpfa, 1
    %x5 = insertvalue { i64, { i64, { { i64, { i64, i8* } }, i1 } } } %xka, { i64, { { i64, { i64, i8* } }, i1 } } %tmpga, 1
    br label %while_start

  while_end:
    %a12 = extractvalue { i64, { i64, { { i64, { i64, i8* } }, i1 } } } %xda, 0
    %xaaa2 = extractvalue { i64, { i64, { { i64, { i64, i8* } }, i1 } } } %xda, 1
    %a1a2 = extractvalue { i64, { { i64, { i64, i8* } }, i1 } } %xaaa2, 0
    %xbaa2 = extractvalue { i64, { { i64, { i64, i8* } }, i1 } } %xaaa2, 1
    %a1b2 = extractvalue { { i64, { i64, i8* } }, i1 } %xbaa2, 0
    %a2b2 = extractvalue { { i64, { i64, i8* } }, i1 } %xbaa2, 1
    %xcaa2 = lshr i64 %a12, 1
    %xdaa1 = icmp ult i64 %xcaa2, 9223372036854775807
    br i1 %xdaa1, label %thena, label %elsea

  thena:
    %xeaa2 = insertvalue { i64, { i64, { i64, i8* } } } zeroinitializer, i64 %xcaa2, 0
    %x6 = insertvalue { i64, { i64, { i64, i8* } } } %xeaa2, { i64, { i64, i8* } } %a1b2, 1
    br label %ctd_ifa

  elsea:
    %xeaa3 = insertvalue { i64, { i64, { i64, i8* } } } zeroinitializer, i64 0, 0
    %x7 = insertvalue { i64, { i64, { i64, i8* } } } %xeaa3, { i64, { i64, i8* } } %a1b2, 1
    br label %ctd_ifa

  ctd_ifa:
    %x8 = phi { i64, { i64, { i64, i8* } } } [ %x7, %elsea ], [ %x6, %thena ]
    ret { i64, { i64, { i64, i8* } } } %x8
}

define { i1, i64 } @CNF_Parser_Impl_parse_skip_block_impl(i8 %x, { i8*, i64 } %x1, i64 %x2) #0 {

  start:
    %x3 = call { { i8, i1 }, i64 } @CNF_Parser_Impl_p_char_impl (i8 %x, { i8*, i64 } %x1, i64 %x2)
    %a1 = extractvalue { { i8, i1 }, i64 } %x3, 0
    %a2 = extractvalue { { i8, i1 }, i64 } %x3, 1
    %a1a = extractvalue { i8, i1 } %a1, 0
    %a2a = extractvalue { i8, i1 } %a1, 1
    br i1 %a2a, label %then, label %else

  then:
    %xa = insertvalue { i1, i64 } zeroinitializer, i1 %a2a, 0
    %x4 = insertvalue { i1, i64 } %xa, i64 %a2, 1
    br label %ctd_if

  else:
    %x5 = call { i1, i64 } @CNF_Parser_Impl_parse_skip_to_impl (i8 10, { i8*, i64 } %x1, i64 %a2)
    br label %ctd_if

  ctd_if:
    %x6 = phi { i1, i64 } [ %x5, %else ], [ %x4, %then ]
    ret { i1, i64 } %x6
}

define { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, i1 } } @CNF_Parser_Impl_read_dimacs_file_impl({ i8*, i64 } %x) #0 {

  start:
    %a1 = extractvalue { i8*, i64 } %x, 0
    %xb = extractvalue { i8*, i64 } %x, 1
    %r = sub i64 0, 1
    %xaa = lshr i64 %r, 1
    %xba = icmp slt i64 %xb, %xaa
    br i1 %xba, label %then, label %else

  then:
    %ra = sub i64 0, 1
    %xca = lshr i64 %ra, 1
    %a1a = extractvalue { i8*, i64 } %x, 0
    %xda = extractvalue { i8*, i64 } %x, 1
    %xea = sub i64 %xca, %xda
    %xfa = sub i64 %xea, 1
    %a1b = extractvalue { i8*, i64 } %x, 0
    %a2 = extractvalue { i8*, i64 } %x, 1
    %xha = call { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } @CNF_Parser_Impl_parse_dimacs2_impl (i64 %xfa, { i8*, i64 } %x, i64 0)
    %a1c = extractvalue { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } %xha, 0
    %a2a = extractvalue { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } %xha, 1
    %a1aa = extractvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 } %a1c, 0
    %a2aa = extractvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 } %a1c, 1
    %xja = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, i1 } } zeroinitializer, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %a1aa, 0
    %xr = insertvalue { i64, i1 } zeroinitializer, i64 %xfa, 0
    %tmpc = insertvalue { i64, i1 } %xr, i1 %a2aa, 1
    %x1 = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, i1 } } %xja, { i64, i1 } %tmpc, 1
    br label %ctd_if

  else:
    %xca1 = call { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } @CNF_Parser_Impl_builder_init_impl (i64 0, i64 0)
    %xda1 = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, i1 } } zeroinitializer, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %xca1, 0
    %xg = insertvalue { i64, i1 } zeroinitializer, i64 0, 0
    %tmpd = insertvalue { i64, i1 } %xg, i1 1, 1
    %x2 = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, i1 } } %xda1, { i64, i1 } %tmpd, 1
    br label %ctd_if

  ctd_if:
    %x3 = phi { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, i1 } } [ %x2, %else ], [ %x1, %then ]
    ret { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, i1 } } %x3
}

define { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { i64, { i64, { i64, i8* } } } } @LRAT_Checker_Impl_delete_clauses_impl({ i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %x, { i64, { i64, { i64, i8* } } } %x1) #0 {

  start:
    %xa = insertvalue { { i64, { i64, { i64, i8* } } }, i1 } zeroinitializer, { i64, { i64, { i64, i8* } } } %x1, 0
    %tmpaa = insertvalue { { i64, { i64, { i64, i8* } } }, i1 } %xa, i1 0, 1
    %xaa = insertvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } zeroinitializer, { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %x, 0
    %xba = insertvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } %xaa, { { i64, { i64, { i64, i8* } } }, i1 } %tmpaa, 1
    br label %while_start

  while_start:
    %xca = phi { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } [ %x6, %ctd_if ], [ %xba, %start ]
    %a1 = extractvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } %xca, 0
    %xaaa = extractvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } %xca, 1
    %a1a = extractvalue { { i64, { i64, { i64, i8* } } }, i1 } %xaaa, 0
    %a2a = extractvalue { { i64, { i64, { i64, i8* } } }, i1 } %xaaa, 1
    %a1b = extractvalue { i64, { i64, { i64, i8* } } } %a1a, 0
    %a2 = extractvalue { i64, { i64, { i64, i8* } } } %a1a, 1
    %xbaa = icmp eq i64 %a1b, 0
    %xcaa = add i1 %xbaa, 1
    %x2 = add i1 %a2a, 1
    %x3 = and i1 %xcaa, %x2
    br i1 %x3, label %while_body, label %while_end

  while_body:
    %a11 = extractvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } %xca, 0
    %xaaa1 = extractvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } %xca, 1
    %a1a1 = extractvalue { { i64, { i64, { i64, i8* } } }, i1 } %xaaa1, 0
    %a2a1 = extractvalue { { i64, { i64, { i64, i8* } } }, i1 } %xaaa1, 1
    %a1b1 = extractvalue { i64, { i64, { i64, i8* } } } %a1a1, 0
    %a21 = extractvalue { i64, { i64, { i64, i8* } } } %a1a1, 1
    %xbaa1 = call { i64, { i64, { i64, i8* } } } @LRAT_Parsers_brd_parse_benc_sid_impl ({ i64, { i64, i8* } } %a21)
    %a1aa = extractvalue { i64, { i64, { i64, i8* } } } %xbaa1, 0
    %a2aa = extractvalue { i64, { i64, { i64, i8* } } } %xbaa1, 1
    %xcaa1 = sub i64 %a1b1, 1
    %xdaa = icmp eq i64 %a1aa, 0
    br i1 %xdaa, label %then, label %else

  then:
    %xea = insertvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } zeroinitializer, { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %a11, 0
    %xoa = insertvalue { i64, { i64, { i64, i8* } } } zeroinitializer, i64 %xcaa1, 0
    %tmpca = insertvalue { i64, { i64, { i64, i8* } } } %xoa, { i64, { i64, i8* } } %a2aa, 1
    %xpa = insertvalue { { i64, { i64, { i64, i8* } } }, i1 } zeroinitializer, { i64, { i64, { i64, i8* } } } %tmpca, 0
    %tmpda = insertvalue { { i64, { i64, { i64, i8* } } }, i1 } %xpa, i1 1, 1
    %x4 = insertvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } %xea, { { i64, { i64, { i64, i8* } } }, i1 } %tmpda, 1
    br label %ctd_if

  else:
    %xea1 = call { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } @LRAT_Checker_Impl_delete_clause_impl (i64 %a1aa, { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %a11)
    %xfa = insertvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } zeroinitializer, { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %xea1, 0
    %xoa1 = insertvalue { i64, { i64, { i64, i8* } } } zeroinitializer, i64 %xcaa1, 0
    %tmpca1 = insertvalue { i64, { i64, { i64, i8* } } } %xoa1, { i64, { i64, i8* } } %a2aa, 1
    %xpa1 = insertvalue { { i64, { i64, { i64, i8* } } }, i1 } zeroinitializer, { i64, { i64, { i64, i8* } } } %tmpca1, 0
    %tmpda1 = insertvalue { { i64, { i64, { i64, i8* } } }, i1 } %xpa1, i1 0, 1
    %x5 = insertvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } %xfa, { { i64, { i64, { i64, i8* } } }, i1 } %tmpda1, 1
    br label %ctd_if

  ctd_if:
    %x6 = phi { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } [ %x5, %else ], [ %x4, %then ]
    br label %while_start

  while_end:
    %a12 = extractvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } %xca, 0
    %xaaa2 = extractvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } %xca, 1
    %a1a2 = extractvalue { { i64, { i64, { i64, i8* } } }, i1 } %xaaa2, 0
    %a2a2 = extractvalue { { i64, { i64, { i64, i8* } } }, i1 } %xaaa2, 1
    %xbaa2 = insertvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { i64, { i64, { i64, i8* } } } } zeroinitializer, { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %a12, 0
    %x7 = insertvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { i64, { i64, { i64, i8* } } } } %xbaa2, { i64, { i64, { i64, i8* } } } %a1a2, 1
    ret { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { i64, { i64, { i64, i8* } } } } %x7
}

define { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, i64 } @LRAT_Checker_Impl_read_dimacs_cs_impl({ i8*, i64 } %x) #0 {

  start:
    %x1 = call { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, i1 } } @CNF_Parser_Impl_read_dimacs_file_impl ({ i8*, i64 } %x)
    %a1 = extractvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, i1 } } %x1, 0
    %xa = extractvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, { i64, i1 } } %x1, 1
    %a1a = extractvalue { i64, i1 } %xa, 0
    %a2a = extractvalue { i64, i1 } %xa, 1
    %xb = call { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } @LRAT_Checker_Impl_builder_finish_building_impl ({ i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %a1)
    br i1 %a2a, label %then, label %else

  then:
    %a1b = extractvalue { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %xb, 0
    %b = extractvalue { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %xb, 1
    %xc = insertvalue { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } zeroinitializer, i1 1, 0
    %xd = insertvalue { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %xc, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } %b, 1
    %xe = insertvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, i64 } zeroinitializer, { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %xd, 0
    %x2 = insertvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, i64 } %xe, i64 %a1a, 1
    br label %ctd_if

  else:
    %xc1 = insertvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, i64 } zeroinitializer, { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %xb, 0
    %x3 = insertvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, i64 } %xc1, i64 %a1a, 1
    br label %ctd_if

  ctd_if:
    %x4 = phi { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, i64 } [ %x3, %else ], [ %x2, %then ]
    ret { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, i64 } %x4
}

define i32 @DS_Clause_Builder_cbld_get_maxlit_impl({ i32, { i64, { i64, i32* } } } %x) #0 {

  start:
    %a = extractvalue { i32, { i64, { i64, i32* } } } %x, 0
    %b = extractvalue { i32, { i64, { i64, i32* } } } %x, 1
    %xc = insertvalue { i32, { { i64, { i64, i32* } }, i1 } } zeroinitializer, i32 %a, 0
    %xd = insertvalue { { i64, { i64, i32* } }, i1 } zeroinitializer, { i64, { i64, i32* } } %b, 0
    %tmpb = insertvalue { { i64, { i64, i32* } }, i1 } %xd, i1 zeroinitializer, 1
    %tmpc = insertvalue { i32, { { i64, { i64, i32* } }, i1 } } %xc, { { i64, { i64, i32* } }, i1 } %tmpb, 1
    %a1 = extractvalue { i32, { { i64, { i64, i32* } }, i1 } } %tmpc, 0
    %aa = extractvalue { i32, { i64, { i64, i32* } } } %x, 0
    %ba = extractvalue { i32, { i64, { i64, i32* } } } %x, 1
    %xba = insertvalue { i32, { { i64, { i64, i32* } }, i1 } } zeroinitializer, i32 %aa, 0
    %xj = insertvalue { { i64, { i64, i32* } }, i1 } zeroinitializer, { i64, { i64, i32* } } %ba, 0
    %tmpac = insertvalue { { i64, { i64, i32* } }, i1 } %xj, i1 zeroinitializer, 1
    %tmpad = insertvalue { i32, { { i64, { i64, i32* } }, i1 } } %xba, { { i64, { i64, i32* } }, i1 } %tmpac, 1
    %xda = extractvalue { i32, { { i64, { i64, i32* } }, i1 } } %tmpad, 1
    %a1a = extractvalue { { i64, { i64, i32* } }, i1 } %xda, 0
    %a2a = extractvalue { { i64, { i64, i32* } }, i1 } %xda, 1
    %xaaa = insertvalue { i32, { i64, { i64, i32* } } } zeroinitializer, i32 %a1, 0
    %xbaa = insertvalue { i32, { i64, { i64, i32* } } } %xaaa, { i64, { i64, i32* } } %a1a, 1
    ret i32 %a1
}

define void @Debugging_Tools_ll_dbg_tag_parsed_impl(i64 %x, i64 %x1) #0 {

  start:
    ret void
}

define i1 @LRAT_Checker_Impl_read_check_lrat_impl({ i8*, i64 } %x) #0 {

  start:
    %x1 = call { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, i64 } @LRAT_Checker_Impl_read_dimacs_cs_impl ({ i8*, i64 } %x)
    %a1 = extractvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, i64 } %x1, 0
    %a2 = extractvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, i64 } %x1, 1
    %a1a = extractvalue { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %a1, 0
    %a2a = extractvalue { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %a1, 1
    br i1 %a1a, label %then, label %else

  then:
    call void @LRAT_Checker_Impl_ll_dbg_tag_parsed_cnf_impl (i8 0)
    call void @LRAT_Checker_Impl_cs_op_free ({ i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %a1)
    br label %ctd_if

  else:
    %xb = call { i64, { i64, { i64, i8* } } } @LRAT_Parsers_brd_rs_new_impl (i64 %a2)
    call void @LRAT_Checker_Impl_ll_dbg_tag_parsed_cnf_impl (i8 1)
    %xd = call { i1, { i64, { i64, { i64, i8* } } } } @LRAT_Checker_Impl_main_checker_loop_impl ({ i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %a1, { i64, { i64, { i64, i8* } } } %xb)
    %c_1 = extractvalue { i1, { i64, { i64, { i64, i8* } } } } %xd, 0
    %xia = extractvalue { i1, { i64, { i64, { i64, i8* } } } } %xd, 1
    %c_11 = extractvalue { i64, { i64, { i64, i8* } } } %xia, 0
    %xib = extractvalue { i64, { i64, { i64, i8* } } } %xia, 1
    %c_12 = extractvalue { i64, { i64, i8* } } %xib, 0
    %xe = extractvalue { i64, { i64, i8* } } %xib, 1
    %c_13 = extractvalue { i64, i8* } %xe, 0
    %xf = extractvalue { i64, i8* } %xe, 1
    call void @LLVM_DS_NArray_narray_free1 (i8* %xf)
    %a1aa = extractvalue { i1, { i64, { i64, { i64, i8* } } } } %xd, 0
    %a2aa = extractvalue { i1, { i64, { i64, { i64, i8* } } } } %xd, 1
    br label %ctd_if

  ctd_if:
    %x2 = phi i1 [ %a1aa, %else ], [ 0, %then ]
    ret i1 %x2
}

define { i32, { i64, { i64, i8* } } } @LRAT_Parsers_brd_parse_benc_ulito_impl({ i64, { i64, i8* } } %x) #0 {

  start:
    %xa = insertvalue { { i64, { i64, i8* } }, i1 } zeroinitializer, { i64, { i64, i8* } } %x, 0
    %tmpba = insertvalue { { i64, { i64, i8* } }, i1 } %xa, i1 0, 1
    %xaa = insertvalue { i32, { { i64, { i64, i8* } }, i1 } } zeroinitializer, i32 0, 0
    %tmpaa = insertvalue { i32, { { i64, { i64, i8* } }, i1 } } %xaa, { { i64, { i64, i8* } }, i1 } %tmpba, 1
    %xba = insertvalue { i32, { i32, { { i64, { i64, i8* } }, i1 } } } zeroinitializer, i32 0, 0
    %xca = insertvalue { i32, { i32, { { i64, { i64, i8* } }, i1 } } } %xba, { i32, { { i64, { i64, i8* } }, i1 } } %tmpaa, 1
    br label %while_start

  while_start:
    %xda = phi { i32, { i32, { { i64, { i64, i8* } }, i1 } } } [ %x5, %ctd_if ], [ %xca, %start ]
    %a1 = extractvalue { i32, { i32, { { i64, { i64, i8* } }, i1 } } } %xda, 0
    %xaaa = extractvalue { i32, { i32, { { i64, { i64, i8* } }, i1 } } } %xda, 1
    %a1a = extractvalue { i32, { { i64, { i64, i8* } }, i1 } } %xaaa, 0
    %xbaa = extractvalue { i32, { { i64, { i64, i8* } }, i1 } } %xaaa, 1
    %a1b = extractvalue { { i64, { i64, i8* } }, i1 } %xbaa, 0
    %a2b = extractvalue { { i64, { i64, i8* } }, i1 } %xbaa, 1
    %xcaa = add i1 %a2b, 1
    %x1 = icmp ult i32 %a1a, 32
    %x2 = and i1 %xcaa, %x1
    br i1 %x2, label %while_body, label %while_end

  while_body:
    %a11 = extractvalue { i32, { i32, { { i64, { i64, i8* } }, i1 } } } %xda, 0
    %xaaa1 = extractvalue { i32, { i32, { { i64, { i64, i8* } }, i1 } } } %xda, 1
    %a1a1 = extractvalue { i32, { { i64, { i64, i8* } }, i1 } } %xaaa1, 0
    %xbaa1 = extractvalue { i32, { { i64, { i64, i8* } }, i1 } } %xaaa1, 1
    %a1b1 = extractvalue { { i64, { i64, i8* } }, i1 } %xbaa1, 0
    %a2b1 = extractvalue { { i64, { i64, i8* } }, i1 } %xbaa1, 1
    %a1c = extractvalue { i64, { i64, i8* } } %a1b1, 0
    %xcaa1 = extractvalue { i64, { i64, i8* } } %a1b1, 1
    %a1aa = extractvalue { i64, i8* } %xcaa1, 0
    %a2a = extractvalue { i64, i8* } %xcaa1, 1
    %xdaa = icmp slt i64 %a1c, %a1aa
    br i1 %xdaa, label %then, label %else

  then:
    %xeaa = getelementptr i8, i8* %a2a, i64 %a1c
    %xfaa = load i8, i8* %xeaa
    %xga = add i64 %a1c, 1
    %xha = insertvalue { i8, { i64, { i64, i8* } } } zeroinitializer, i8 %xfaa, 0
    %xra = insertvalue { i64, i8* } zeroinitializer, i64 %a1aa, 0
    %tmpda = insertvalue { i64, i8* } %xra, i8* %a2a, 1
    %xsa = insertvalue { i64, { i64, i8* } } zeroinitializer, i64 %xga, 0
    %tmpea = insertvalue { i64, { i64, i8* } } %xsa, { i64, i8* } %tmpda, 1
    %x3 = insertvalue { i8, { i64, { i64, i8* } } } %xha, { i64, { i64, i8* } } %tmpea, 1
    br label %ctd_if

  else:
    %x4 = call { i8, { i64, { i64, i8* } } } @LRAT_Parsers_brd_refill_impl (i64 %a1c, i64 %a1aa, i8* %a2a)
    br label %ctd_if

  ctd_if:
    %xeaa1 = phi { i8, { i64, { i64, i8* } } } [ %x4, %else ], [ %x3, %then ]
    %a1ca = extractvalue { i8, { i64, { i64, i8* } } } %xeaa1, 0
    %a2c = extractvalue { i8, { i64, { i64, i8* } } } %xeaa1, 1
    %tmpcc = and i8 %a1ca, 127
    %xfaa1 = zext i8 %tmpcc to i32
    %xga1 = shl i32 %xfaa1, %a1a1
    %xha1 = add i32 %a1a1, 7
    %tmpd = and i8 %a1ca, 128
    %xja = icmp eq i8 %tmpd, 0
    %tmpab = or i32 %a11, %xga1
    %xka = insertvalue { i32, { i32, { { i64, { i64, i8* } }, i1 } } } zeroinitializer, i32 %tmpab, 0
    %xwa = insertvalue { { i64, { i64, i8* } }, i1 } zeroinitializer, { i64, { i64, i8* } } %a2c, 0
    %tmpfa = insertvalue { { i64, { i64, i8* } }, i1 } %xwa, i1 %xja, 1
    %xxa = insertvalue { i32, { { i64, { i64, i8* } }, i1 } } zeroinitializer, i32 %xha1, 0
    %tmpga = insertvalue { i32, { { i64, { i64, i8* } }, i1 } } %xxa, { { i64, { i64, i8* } }, i1 } %tmpfa, 1
    %x5 = insertvalue { i32, { i32, { { i64, { i64, i8* } }, i1 } } } %xka, { i32, { { i64, { i64, i8* } }, i1 } } %tmpga, 1
    br label %while_start

  while_end:
    %a12 = extractvalue { i32, { i32, { { i64, { i64, i8* } }, i1 } } } %xda, 0
    %xaaa2 = extractvalue { i32, { i32, { { i64, { i64, i8* } }, i1 } } } %xda, 1
    %a1a2 = extractvalue { i32, { { i64, { i64, i8* } }, i1 } } %xaaa2, 0
    %xbaa2 = extractvalue { i32, { { i64, { i64, i8* } }, i1 } } %xaaa2, 1
    %a1b2 = extractvalue { { i64, { i64, i8* } }, i1 } %xbaa2, 0
    %a2b2 = extractvalue { { i64, { i64, i8* } }, i1 } %xbaa2, 1
    %xcaa2 = icmp eq i32 %a12, 1
    br i1 %xcaa2, label %thena, label %elsea

  thena:
    %xeaa2 = insertvalue { i32, { i64, { i64, i8* } } } zeroinitializer, i32 0, 0
    %x6 = insertvalue { i32, { i64, { i64, i8* } } } %xeaa2, { i64, { i64, i8* } } %a1b2, 1
    br label %ctd_ifa

  elsea:
    %xeaa3 = insertvalue { i32, { i64, { i64, i8* } } } zeroinitializer, i32 %a12, 0
    %x7 = insertvalue { i32, { i64, { i64, i8* } } } %xeaa3, { i64, { i64, i8* } } %a1b2, 1
    br label %ctd_ifa

  ctd_ifa:
    %x8 = phi { i32, { i64, { i64, i8* } } } [ %x7, %elsea ], [ %x6, %thena ]
    ret { i32, { i64, { i64, i8* } } } %x8
}

define { { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } }, { i64, { i64, { i64, i8* } } } } @LRAT_Checker_Impl_prove_units_loop_impl({ i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } %x, { i64, { i64, { i64, i8* } } } %x1) #0 {

  start:
    %xa = insertvalue { { i64, { i64, { i64, i8* } } }, i1 } zeroinitializer, { i64, { i64, { i64, i8* } } } %x1, 0
    %tmpaa = insertvalue { { i64, { i64, { i64, i8* } } }, i1 } %xa, i1 0, 1
    %xaa = insertvalue { { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } zeroinitializer, { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } %x, 0
    %xba = insertvalue { { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } %xaa, { { i64, { i64, { i64, i8* } } }, i1 } %tmpaa, 1
    br label %while_start

  while_start:
    %xca = phi { { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } [ %x6, %ctd_if ], [ %xba, %start ]
    %a1 = extractvalue { { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } %xca, 0
    %xaaa = extractvalue { { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } %xca, 1
    %a1a = extractvalue { { i64, { i64, { i64, i8* } } }, i1 } %xaaa, 0
    %a2a = extractvalue { { i64, { i64, { i64, i8* } } }, i1 } %xaaa, 1
    %a1b = extractvalue { i64, { i64, { i64, i8* } } } %a1a, 0
    %a2 = extractvalue { i64, { i64, { i64, i8* } } } %a1a, 1
    %xbaa = icmp eq i64 %a1b, 0
    %xcaa = add i1 %xbaa, 1
    %x2 = add i1 %a2a, 1
    %x3 = and i1 %xcaa, %x2
    br i1 %x3, label %while_body, label %while_end

  while_body:
    %a11 = extractvalue { { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } %xca, 0
    %xaaa1 = extractvalue { { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } %xca, 1
    %a1a1 = extractvalue { { i64, { i64, { i64, i8* } } }, i1 } %xaaa1, 0
    %a2a1 = extractvalue { { i64, { i64, { i64, i8* } } }, i1 } %xaaa1, 1
    %a1b1 = extractvalue { i64, { i64, { i64, i8* } } } %a1a1, 0
    %a21 = extractvalue { i64, { i64, { i64, i8* } } } %a1a1, 1
    %xbaa1 = call { i64, { i64, { i64, i8* } } } @LRAT_Parsers_brd_parse_benc_sid_impl ({ i64, { i64, i8* } } %a21)
    %a1aa = extractvalue { i64, { i64, { i64, i8* } } } %xbaa1, 0
    %a2aa = extractvalue { i64, { i64, { i64, i8* } } } %xbaa1, 1
    %xcaa1 = sub i64 %a1b1, 1
    call void @Debugging_Tools_ll_dbg_tag_parsed_impl (i64 4, i64 %a1aa)
    %xfa = icmp eq i64 %a1aa, 0
    br i1 %xfa, label %then, label %else

  then:
    %xga = insertvalue { { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } zeroinitializer, { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } %a11, 0
    %xoa = insertvalue { i64, { i64, { i64, i8* } } } zeroinitializer, i64 %xcaa1, 0
    %tmpda = insertvalue { i64, { i64, { i64, i8* } } } %xoa, { i64, { i64, i8* } } %a2aa, 1
    %xpa = insertvalue { { i64, { i64, { i64, i8* } } }, i1 } zeroinitializer, { i64, { i64, { i64, i8* } } } %tmpda, 0
    %tmpea = insertvalue { { i64, { i64, { i64, i8* } } }, i1 } %xpa, i1 1, 1
    %x4 = insertvalue { { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } %xga, { { i64, { i64, { i64, i8* } } }, i1 } %tmpea, 1
    br label %ctd_if

  else:
    %xga1 = call { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } @LRAT_Checker_Impl_proof_step_impl (i64 %a1aa, { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } %a11)
    %xha = insertvalue { { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } zeroinitializer, { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } %xga1, 0
    %xoa1 = insertvalue { i64, { i64, { i64, i8* } } } zeroinitializer, i64 %xcaa1, 0
    %tmpda1 = insertvalue { i64, { i64, { i64, i8* } } } %xoa1, { i64, { i64, i8* } } %a2aa, 1
    %xpa1 = insertvalue { { i64, { i64, { i64, i8* } } }, i1 } zeroinitializer, { i64, { i64, { i64, i8* } } } %tmpda1, 0
    %tmpea1 = insertvalue { { i64, { i64, { i64, i8* } } }, i1 } %xpa1, i1 0, 1
    %x5 = insertvalue { { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } %xha, { { i64, { i64, { i64, i8* } } }, i1 } %tmpea1, 1
    br label %ctd_if

  ctd_if:
    %x6 = phi { { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } [ %x5, %else ], [ %x4, %then ]
    br label %while_start

  while_end:
    %a12 = extractvalue { { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } %xca, 0
    %xaaa2 = extractvalue { { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } %xca, 1
    %a1a2 = extractvalue { { i64, { i64, { i64, i8* } } }, i1 } %xaaa2, 0
    %a2a2 = extractvalue { { i64, { i64, { i64, i8* } } }, i1 } %xaaa2, 1
    %xbaa2 = insertvalue { { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } }, { i64, { i64, { i64, i8* } } } } zeroinitializer, { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } %a12, 0
    %x7 = insertvalue { { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } }, { i64, { i64, { i64, i8* } } } } %xbaa2, { i64, { i64, { i64, i8* } } } %a1a2, 1
    ret { { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } }, { i64, { i64, { i64, i8* } } } } %x7
}

define { i32, { i64, { i64, i32* } } } @DS_Clause_Builder_cbld_abort_clause_impl({ i32, { i64, { i64, i32* } } } %x) #0 {

  start:
    %a = extractvalue { i32, { i64, { i64, i32* } } } %x, 0
    %b = extractvalue { i32, { i64, { i64, i32* } } } %x, 1
    %xc = insertvalue { i32, { { i64, { i64, i32* } }, i1 } } zeroinitializer, i32 %a, 0
    %xda = insertvalue { { i64, { i64, i32* } }, i1 } zeroinitializer, { i64, { i64, i32* } } %b, 0
    %tmpba = insertvalue { { i64, { i64, i32* } }, i1 } %xda, i1 zeroinitializer, 1
    %tmpc = insertvalue { i32, { { i64, { i64, i32* } }, i1 } } %xc, { { i64, { i64, i32* } }, i1 } %tmpba, 1
    %a1 = extractvalue { i32, { { i64, { i64, i32* } }, i1 } } %tmpc, 0
    %aa = extractvalue { i32, { i64, { i64, i32* } } } %x, 0
    %ba = extractvalue { i32, { i64, { i64, i32* } } } %x, 1
    %xba = insertvalue { i32, { { i64, { i64, i32* } }, i1 } } zeroinitializer, i32 %aa, 0
    %xja = insertvalue { { i64, { i64, i32* } }, i1 } zeroinitializer, { i64, { i64, i32* } } %ba, 0
    %tmpac = insertvalue { { i64, { i64, i32* } }, i1 } %xja, i1 zeroinitializer, 1
    %tmpad = insertvalue { i32, { { i64, { i64, i32* } }, i1 } } %xba, { { i64, { i64, i32* } }, i1 } %tmpac, 1
    %xdaa = extractvalue { i32, { { i64, { i64, i32* } }, i1 } } %tmpad, 1
    %a1a = extractvalue { { i64, { i64, i32* } }, i1 } %xdaa, 0
    %a2a = extractvalue { { i64, { i64, i32* } }, i1 } %xdaa, 1
    %xaaa = call { i64, { i64, i32* } } @DS_Clause_Buffer_cbuf_flush_impl ({ i64, { i64, i32* } } %a1a)
    %xbaa = insertvalue { i32, { i64, { i64, i32* } } } zeroinitializer, i32 %a1, 0
    %x1 = insertvalue { i32, { i64, { i64, i32* } } } %xbaa, { i64, { i64, i32* } } %xaaa, 1
    ret { i32, { i64, { i64, i32* } } } %x1
}

define { { i64, i1* }, { i64, { i64, i32* } } } @DS_Reversible_Assignment_rpan_clear_impl(i64 %x, { { i64, i1* }, { i64, { i64, i32* } } } %x1) #0 {

  start:
    %a = extractvalue { { i64, i1* }, { i64, { i64, i32* } } } %x1, 0
    %b = extractvalue { { i64, i1* }, { i64, { i64, i32* } } } %x1, 1
    %xc = insertvalue { { i64, i1* }, { { i64, { i64, i32* } }, i1 } } zeroinitializer, { i64, i1* } %a, 0
    %xda = insertvalue { { i64, { i64, i32* } }, i1 } zeroinitializer, { i64, { i64, i32* } } %b, 0
    %tmpba = insertvalue { { i64, { i64, i32* } }, i1 } %xda, i1 zeroinitializer, 1
    %tmpc = insertvalue { { i64, i1* }, { { i64, { i64, i32* } }, i1 } } %xc, { { i64, { i64, i32* } }, i1 } %tmpba, 1
    %a1 = extractvalue { { i64, i1* }, { { i64, { i64, i32* } }, i1 } } %tmpc, 0
    %aa = extractvalue { { i64, i1* }, { i64, { i64, i32* } } } %x1, 0
    %ba = extractvalue { { i64, i1* }, { i64, { i64, i32* } } } %x1, 1
    %xba = insertvalue { { i64, i1* }, { { i64, { i64, i32* } }, i1 } } zeroinitializer, { i64, i1* } %aa, 0
    %xia = insertvalue { { i64, { i64, i32* } }, i1 } zeroinitializer, { i64, { i64, i32* } } %ba, 0
    %tmpac = insertvalue { { i64, { i64, i32* } }, i1 } %xia, i1 zeroinitializer, 1
    %tmpad = insertvalue { { i64, i1* }, { { i64, { i64, i32* } }, i1 } } %xba, { { i64, { i64, i32* } }, i1 } %tmpac, 1
    %xdaa = extractvalue { { i64, i1* }, { { i64, { i64, i32* } }, i1 } } %tmpad, 1
    %a1a = extractvalue { { i64, { i64, i32* } }, i1 } %xdaa, 0
    %a2a = extractvalue { { i64, { i64, i32* } }, i1 } %xdaa, 1
    %xga = insertvalue { i64, { i64, i1* } } zeroinitializer, i64 0, 0
    %xha = insertvalue { i64, { i64, i1* } } %xga, { i64, i1* } %a1, 1
    br label %while_start

  while_start:
    %xaaa = phi { i64, { i64, i1* } } [ %x3, %while_body ], [ %xha, %start ]
    %a1b = extractvalue { i64, { i64, i1* } } %xaaa, 0
    %a2b = extractvalue { i64, { i64, i1* } } %xaaa, 1
    %l = extractvalue { i64, { i64, i32* } } %a1a, 0
    %xbaa = extractvalue { i64, { i64, i32* } } %a1a, 1
    %c = extractvalue { i64, i32* } %xbaa, 0
    %ab = extractvalue { i64, i32* } %xbaa, 1
    %xdaaa = icmp slt i64 %a1b, %l
    %x2 = and i1 %xdaaa, 1
    br i1 %x2, label %while_body, label %while_end

  while_body:
    %a1b1 = extractvalue { i64, { i64, i1* } } %xaaa, 0
    %a2b1 = extractvalue { i64, { i64, i1* } } %xaaa, 1
    %l1 = extractvalue { i64, { i64, i32* } } %a1a, 0
    %xbaa1 = extractvalue { i64, { i64, i32* } } %a1a, 1
    %c1 = extractvalue { i64, i32* } %xbaa1, 0
    %ab1 = extractvalue { i64, i32* } %xbaa1, 1
    %xcaa = getelementptr i32, i32* %ab1, i64 %a1b1
    %xdaaa1 = load i32, i32* %xcaa
    %xeaaa = zext i32 %xdaaa1 to i64
    %a1c = extractvalue { i64, i1* } %a2b1, 0
    %a2 = extractvalue { i64, i1* } %a2b1, 1
    %p = getelementptr i1, i1* %a2, i64 %xeaaa
    store i1 0, i1* %p
    %xgaa = insertvalue { i64, i1* } zeroinitializer, i64 %a1c, 0
    %xhaa = insertvalue { i64, i1* } %xgaa, i1* %a2, 1
    %xiaaa = add i64 %a1b1, 1
    %xjaaa = insertvalue { i64, { i64, i1* } } zeroinitializer, i64 %xiaaa, 0
    %x3 = insertvalue { i64, { i64, i1* } } %xjaaa, { i64, i1* } %xhaa, 1
    br label %while_start

  while_end:
    %l2 = extractvalue { i64, { i64, i32* } } %a1a, 0
    %xbaa2 = extractvalue { i64, { i64, i32* } } %a1a, 1
    %c2 = extractvalue { i64, i32* } %xbaa2, 0
    %ab2 = extractvalue { i64, i32* } %xbaa2, 1
    %xcaa1 = insertvalue { i64, { i64, i32* } } zeroinitializer, i64 0, 0
    %xna = insertvalue { i64, i32* } zeroinitializer, i64 %c2, 0
    %tmpdaa = insertvalue { i64, i32* } %xna, i32* %ab2, 1
    %xdaaa2 = insertvalue { i64, { i64, i32* } } %xcaa1, { i64, i32* } %tmpdaa, 1
    %ac = extractvalue { i64, { i64, i1* } } %xaaa, 0
    %tmpaba = extractvalue { i64, { i64, i1* } } %xaaa, 1
    %xeaaa1 = insertvalue { { i64, i1* }, { i64, { i64, i32* } } } zeroinitializer, { i64, i1* } %tmpaba, 0
    %x4 = insertvalue { { i64, i1* }, { i64, { i64, i32* } } } %xeaaa1, { i64, { i64, i32* } } %xdaaa2, 1
    ret { { i64, i1* }, { i64, { i64, i32* } } } %x4
}

define { { i64, i1* }, { i64, { i64, i32* } } } @DS_Reversible_Assignment_rpan_empty_impl(i32 %x, i64 %x1) #0 {

  start:
    %xa = or i32 %x, 1
    %xaa = zext i32 %xa to i64
    %xba = add i64 %xaa, 1
    %tmp = icmp eq i64 %xba, 0
    br i1 %tmp, label %then, label %else

  then:
    br label %ctd_if

  else:
    %t = getelementptr i1, i1* null, i64 1
    %a = ptrtoint i1* %t to i64
    %b = call i8* @isabelle_llvm_calloc (i64 %xba, i64 %a)
    %x2 = bitcast i8* %b to i1*
    br label %ctd_if

  ctd_if:
    %xca = phi i1* [ %x2, %else ], [ null, %then ]
    %xda = insertvalue { i64, i1* } zeroinitializer, i64 %xba, 0
    %xea = insertvalue { i64, i1* } %xda, i1* %xca, 1
    %tmpb = icmp eq i64 8, 0
    br i1 %tmpb, label %thena, label %elsea

  thena:
    br label %ctd_ifa

  elsea:
    %ta = getelementptr i32, i32* null, i64 1
    %c = ptrtoint i32* %ta to i64
    %d = call i8* @isabelle_llvm_calloc (i64 8, i64 %c)
    %x3 = bitcast i8* %d to i32*
    br label %ctd_ifa

  ctd_ifa:
    %aa = phi i32* [ %x3, %elsea ], [ null, %thena ]
    %xfa = insertvalue { i64, { i64, i32* } } zeroinitializer, i64 0, 0
    %xha = insertvalue { i64, i32* } zeroinitializer, i64 8, 0
    %tmpda = insertvalue { i64, i32* } %xha, i32* %aa, 1
    %xga = insertvalue { i64, { i64, i32* } } %xfa, { i64, i32* } %tmpda, 1
    %xhaa = insertvalue { { i64, i1* }, { i64, { i64, i32* } } } zeroinitializer, { i64, i1* } %xea, 0
    %x4 = insertvalue { { i64, i1* }, { i64, { i64, i32* } } } %xhaa, { i64, { i64, i32* } } %xga, 1
    ret { { i64, i1* }, { i64, { i64, i32* } } } %x4
}

define void @Debugging_Tools_ll_dbg_tag_err_code_impl(i64 %x, i64 %x1) #0 {

  start:
    ret void
}

define { { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } }, { i64, { i64, { i64, i8* } } } } @LRAT_Checker_Impl_add_literals_loop_impl({ i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %x, { i64, { i64, { i64, i8* } } } %x1) #0 {

  start:
    %x2 = insertvalue { { i64, { i64, { i64, i8* } } }, i1 } zeroinitializer, { i64, { i64, { i64, i8* } } } %x1, 0
    %tmpa = insertvalue { { i64, { i64, { i64, i8* } } }, i1 } %x2, i1 1, 1
    %xa = insertvalue { { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } zeroinitializer, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %x, 0
    %xb = insertvalue { { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } %xa, { { i64, { i64, { i64, i8* } } }, i1 } %tmpa, 1
    br label %while_start

  while_start:
    %xc = phi { { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } [ %x6, %ctd_if ], [ %xb, %start ]
    %a1 = extractvalue { { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } %xc, 0
    %xaa = extractvalue { { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } %xc, 1
    %a1a = extractvalue { { i64, { i64, { i64, i8* } } }, i1 } %xaa, 0
    %a2a = extractvalue { { i64, { i64, { i64, i8* } } }, i1 } %xaa, 1
    %a1b = extractvalue { i64, { i64, { i64, i8* } } } %a1a, 0
    %a2 = extractvalue { i64, { i64, { i64, i8* } } } %a1a, 1
    %xba = icmp eq i64 %a1b, 0
    %xca = add i1 %xba, 1
    %x3 = and i1 %xca, %a2a
    br i1 %x3, label %while_body, label %while_end

  while_body:
    %a11 = extractvalue { { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } %xc, 0
    %xaa1 = extractvalue { { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } %xc, 1
    %a1a1 = extractvalue { { i64, { i64, { i64, i8* } } }, i1 } %xaa1, 0
    %a2a1 = extractvalue { { i64, { i64, { i64, i8* } } }, i1 } %xaa1, 1
    %a1b1 = extractvalue { i64, { i64, { i64, i8* } } } %a1a1, 0
    %a21 = extractvalue { i64, { i64, { i64, i8* } } } %a1a1, 1
    %xba1 = call { i32, { i64, { i64, i8* } } } @LRAT_Parsers_brd_parse_benc_ulito_impl ({ i64, { i64, i8* } } %a21)
    %a1aa = extractvalue { i32, { i64, { i64, i8* } } } %xba1, 0
    %a2aa = extractvalue { i32, { i64, { i64, i8* } } } %xba1, 1
    %xca1 = sub i64 %a1b1, 1
    %xea = zext i32 %a1aa to i64
    call void @Debugging_Tools_ll_dbg_tag_parsed_impl (i64 3, i64 %xea)
    %xga = icmp eq i32 %a1aa, 0
    br i1 %xga, label %then, label %else

  then:
    %xha = insertvalue { { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } zeroinitializer, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %a11, 0
    %xo = insertvalue { i64, { i64, { i64, i8* } } } zeroinitializer, i64 %xca1, 0
    %tmpd = insertvalue { i64, { i64, { i64, i8* } } } %xo, { i64, { i64, i8* } } %a2aa, 1
    %xp = insertvalue { { i64, { i64, { i64, i8* } } }, i1 } zeroinitializer, { i64, { i64, { i64, i8* } } } %tmpd, 0
    %tmpe = insertvalue { { i64, { i64, { i64, i8* } } }, i1 } %xp, i1 0, 1
    %x4 = insertvalue { { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } %xha, { { i64, { i64, { i64, i8* } } }, i1 } %tmpe, 1
    br label %ctd_if

  else:
    %xia = call { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } @LRAT_Checker_Impl_add_literal_impl (i32 %a1aa, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %a11)
    %xja = insertvalue { { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } zeroinitializer, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %xia, 0
    %xo1 = insertvalue { i64, { i64, { i64, i8* } } } zeroinitializer, i64 %xca1, 0
    %tmpd1 = insertvalue { i64, { i64, { i64, i8* } } } %xo1, { i64, { i64, i8* } } %a2aa, 1
    %xp1 = insertvalue { { i64, { i64, { i64, i8* } } }, i1 } zeroinitializer, { i64, { i64, { i64, i8* } } } %tmpd1, 0
    %tmpe1 = insertvalue { { i64, { i64, { i64, i8* } } }, i1 } %xp1, i1 1, 1
    %x5 = insertvalue { { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } %xja, { { i64, { i64, { i64, i8* } } }, i1 } %tmpe1, 1
    br label %ctd_if

  ctd_if:
    %x6 = phi { { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } [ %x5, %else ], [ %x4, %then ]
    br label %while_start

  while_end:
    %a12 = extractvalue { { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } %xc, 0
    %xaa2 = extractvalue { { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } }, { { i64, { i64, { i64, i8* } } }, i1 } } %xc, 1
    %a1a2 = extractvalue { { i64, { i64, { i64, i8* } } }, i1 } %xaa2, 0
    %a2a2 = extractvalue { { i64, { i64, { i64, i8* } } }, i1 } %xaa2, 1
    br i1 %a2a2, label %thena, label %elsea

  thena:
    call void @Debugging_Tools_ll_dbg_tag_err_code_impl (i64 5, i64 0)
    %xca2 = call { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } @LRAT_Checker_Impl_start_proof_error_impl ({ i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %a12)
    %xda = insertvalue { { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } }, { i64, { i64, { i64, i8* } } } } zeroinitializer, { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } %xca2, 0
    %x7 = insertvalue { { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } }, { i64, { i64, { i64, i8* } } } } %xda, { i64, { i64, { i64, i8* } } } %a1a2, 1
    br label %ctd_ifa

  elsea:
    %xba2 = call { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } @LRAT_Checker_Impl_start_proof_impl ({ i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %a12)
    %xca3 = insertvalue { { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } }, { i64, { i64, { i64, i8* } } } } zeroinitializer, { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } %xba2, 0
    %x8 = insertvalue { { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } }, { i64, { i64, { i64, i8* } } } } %xca3, { i64, { i64, { i64, i8* } } } %a1a2, 1
    br label %ctd_ifa

  ctd_ifa:
    %x9 = phi { { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } }, { i64, { i64, { i64, i8* } } } } [ %x8, %elsea ], [ %x7, %thena ]
    ret { { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } }, { i64, { i64, { i64, i8* } } } } %x9
}

define { i1, { i64, { i64, { i64, i8* } } } } @LRAT_Checker_Impl_main_checker_loop_impl({ i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %x, { i64, { i64, { i64, i8* } } } %x1) #0 {

  start:
    %xa = insertvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { i64, { i64, { i64, i8* } } } } zeroinitializer, { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %x, 0
    %xaa = insertvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { i64, { i64, { i64, i8* } } } } %xa, { i64, { i64, { i64, i8* } } } %x1, 1
    br label %while_start

  while_start:
    %xba = phi { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { i64, { i64, { i64, i8* } } } } [ %x10, %ctd_ifa ], [ %xaa, %start ]
    %a1 = extractvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { i64, { i64, { i64, i8* } } } } %xba, 0
    %a2 = extractvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { i64, { i64, { i64, i8* } } } } %xba, 1
    %a1a = extractvalue { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %a1, 0
    %a2a = extractvalue { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %a1, 1
    %xbaa = add i1 %a1a, 1
    %a1b = extractvalue { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %a1, 0
    %b = extractvalue { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %a1, 1
    %a1aa = extractvalue { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } %b, 0
    %ba = extractvalue { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } %b, 1
    %a1ba = extractvalue { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } %ba, 0
    %a2b = extractvalue { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } %ba, 1
    %xda = add i1 %a1aa, 1
    %a1c = extractvalue { i64, { i64, { i64, i8* } } } %a2, 0
    %a2c = extractvalue { i64, { i64, { i64, i8* } } } %a2, 1
    %xea = icmp eq i64 %a1c, 0
    %xfa = add i1 %xea, 1
    %x2 = and i1 %xda, %xfa
    %x3 = and i1 %xbaa, %x2
    br i1 %x3, label %while_body, label %while_end

  while_body:
    %a11 = extractvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { i64, { i64, { i64, i8* } } } } %xba, 0
    %a21 = extractvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { i64, { i64, { i64, i8* } } } } %xba, 1
    %a1a1 = extractvalue { i64, { i64, { i64, i8* } } } %a21, 0
    %a2a1 = extractvalue { i64, { i64, { i64, i8* } } } %a21, 1
    %a1b1 = extractvalue { i64, { i64, i8* } } %a2a1, 0
    %xaaa = extractvalue { i64, { i64, i8* } } %a2a1, 1
    %a1aa1 = extractvalue { i64, i8* } %xaaa, 0
    %a2aa = extractvalue { i64, i8* } %xaaa, 1
    %xbaa1 = icmp slt i64 %a1b1, %a1aa1
    br i1 %xbaa1, label %then, label %else

  then:
    %xca = getelementptr i8, i8* %a2aa, i64 %a1b1
    %xda1 = load i8, i8* %xca
    %xea1 = add i64 %a1b1, 1
    %xfa1 = insertvalue { i8, { i64, { i64, i8* } } } zeroinitializer, i8 %xda1, 0
    %xma = insertvalue { i64, i8* } zeroinitializer, i64 %a1aa1, 0
    %tmpab = insertvalue { i64, i8* } %xma, i8* %a2aa, 1
    %xna = insertvalue { i64, { i64, i8* } } zeroinitializer, i64 %xea1, 0
    %tmpba = insertvalue { i64, { i64, i8* } } %xna, { i64, i8* } %tmpab, 1
    %x4 = insertvalue { i8, { i64, { i64, i8* } } } %xfa1, { i64, { i64, i8* } } %tmpba, 1
    br label %ctd_if

  else:
    %x5 = call { i8, { i64, { i64, i8* } } } @LRAT_Parsers_brd_refill_impl (i64 %a1b1, i64 %a1aa1, i8* %a2aa)
    br label %ctd_if

  ctd_if:
    %xca1 = phi { i8, { i64, { i64, i8* } } } [ %x5, %else ], [ %x4, %then ]
    %a1ab = extractvalue { i8, { i64, { i64, i8* } } } %xca1, 0
    %a2ab = extractvalue { i8, { i64, { i64, i8* } } } %xca1, 1
    %xda2 = sub i64 %a1a1, 1
    %xea2 = icmp eq i8 %a1ab, 97
    br i1 %xea2, label %thena, label %elsea

  thena:
    %xoa = insertvalue { i64, { i64, { i64, i8* } } } zeroinitializer, i64 %xda2, 0
    %tmpb = insertvalue { i64, { i64, { i64, i8* } } } %xoa, { i64, { i64, i8* } } %a2ab, 1
    %a1c1 = extractvalue { i64, { i64, { i64, i8* } } } %tmpb, 0
    %xqa = insertvalue { i64, { i64, { i64, i8* } } } zeroinitializer, i64 %xda2, 0
    %tmpab1 = insertvalue { i64, { i64, { i64, i8* } } } %xqa, { i64, { i64, i8* } } %a2ab, 1
    %a2b1 = extractvalue { i64, { i64, { i64, i8* } } } %tmpab1, 1
    %xfa2 = call { i64, { i64, { i64, i8* } } } @LRAT_Parsers_brd_parse_benc_sid_impl ({ i64, { i64, i8* } } %a2b1)
    %a1ac = extractvalue { i64, { i64, { i64, i8* } } } %xfa2, 0
    %a2ac = extractvalue { i64, { i64, { i64, i8* } } } %xfa2, 1
    call void @Debugging_Tools_ll_dbg_tag_parsed_impl (i64 2, i64 %a1ac)
    %xua = insertvalue { i64, { i64, { i64, i8* } } } zeroinitializer, i64 %a1c1, 0
    %tmpca = insertvalue { i64, { i64, { i64, i8* } } } %xua, { i64, { i64, i8* } } %a2ac, 1
    %a1d = extractvalue { i64, { i64, { i64, i8* } } } %tmpca, 0
    %xwa = insertvalue { i64, { i64, { i64, i8* } } } zeroinitializer, i64 %a1c1, 0
    %tmpda = insertvalue { i64, { i64, { i64, i8* } } } %xwa, { i64, { i64, i8* } } %a2ac, 1
    %a2c1 = extractvalue { i64, { i64, { i64, i8* } } } %tmpda, 1
    %xja = call { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } @LRAT_Checker_Impl_start_lemma_impl (i64 %a1d, { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %a11)
    %xya = insertvalue { i64, { i64, { i64, i8* } } } zeroinitializer, i64 %a1c1, 0
    %xza = insertvalue { i64, { i64, { i64, i8* } } } %xya, { i64, { i64, i8* } } %a2ac, 1
    %xka = call { { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } }, { i64, { i64, { i64, i8* } } } } @LRAT_Checker_Impl_add_literals_loop_impl ({ i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %xja, { i64, { i64, { i64, i8* } } } %xza)
    %a1ca = extractvalue { { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } }, { i64, { i64, { i64, i8* } } } } %xka, 0
    %a2ca = extractvalue { { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } }, { i64, { i64, { i64, i8* } } } } %xka, 1
    %xla = call { { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } }, { i64, { i64, { i64, i8* } } } } @LRAT_Checker_Impl_prove_units_loop_impl ({ i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } %a1ca, { i64, { i64, { i64, i8* } } } %a2ca)
    %a1da = extractvalue { { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } }, { i64, { i64, { i64, i8* } } } } %xla, 0
    %a2d = extractvalue { { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } }, { i64, { i64, { i64, i8* } } } } %xla, 1
    %xma1 = call { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } @LRAT_Checker_Impl_finish_proof_impl (i64 %a1ac, { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } %a1da)
    %xna1 = insertvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { i64, { i64, { i64, i8* } } } } zeroinitializer, { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %xma1, 0
    %x6 = insertvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { i64, { i64, { i64, i8* } } } } %xna1, { i64, { i64, { i64, i8* } } } %a2d, 1
    br label %ctd_ifa

  elsea:
    %xfa3 = icmp eq i8 %a1ab, 100
    br i1 %xfa3, label %thenb, label %elseb

  thenb:
    %xpa = insertvalue { i64, { i64, { i64, i8* } } } zeroinitializer, i64 %xda2, 0
    %xqa1 = insertvalue { i64, { i64, { i64, i8* } } } %xpa, { i64, { i64, i8* } } %a2ab, 1
    %xga = call { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { i64, { i64, { i64, i8* } } } } @LRAT_Checker_Impl_delete_clauses_impl ({ i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %a11, { i64, { i64, { i64, i8* } } } %xqa1)
    %a = extractvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { i64, { i64, { i64, i8* } } } } %xga, 0
    %b1 = extractvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { i64, { i64, { i64, i8* } } } } %xga, 1
    %xha = insertvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { i64, { i64, { i64, i8* } } } } zeroinitializer, { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %a, 0
    %x7 = insertvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { i64, { i64, { i64, i8* } } } } %xha, { i64, { i64, { i64, i8* } } } %b1, 1
    br label %ctd_ifb

  elseb:
    call void @Debugging_Tools_ll_dbg_tag_err_code_impl (i64 1, i64 0)
    %a1c2 = extractvalue { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %a11, 0
    %b2 = extractvalue { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %a11, 1
    %xha1 = insertvalue { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } zeroinitializer, i1 1, 0
    %xia = insertvalue { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %xha1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } %b2, 1
    %xja1 = insertvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { i64, { i64, { i64, i8* } } } } zeroinitializer, { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %xia, 0
    %xva = insertvalue { i64, { i64, { i64, i8* } } } zeroinitializer, i64 %xda2, 0
    %tmpca1 = insertvalue { i64, { i64, { i64, i8* } } } %xva, { i64, { i64, i8* } } %a2ab, 1
    %x8 = insertvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { i64, { i64, { i64, i8* } } } } %xja1, { i64, { i64, { i64, i8* } } } %tmpca1, 1
    br label %ctd_ifb

  ctd_ifb:
    %x9 = phi { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { i64, { i64, { i64, i8* } } } } [ %x8, %elseb ], [ %x7, %thenb ]
    br label %ctd_ifa

  ctd_ifa:
    %x10 = phi { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { i64, { i64, { i64, i8* } } } } [ %x9, %ctd_ifb ], [ %x6, %thena ]
    br label %while_start

  while_end:
    %a12 = extractvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { i64, { i64, { i64, i8* } } } } %xba, 0
    %a22 = extractvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { i64, { i64, { i64, i8* } } } } %xba, 1
    %a1a2 = extractvalue { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %a12, 0
    %a2a2 = extractvalue { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %a12, 1
    %xbaa2 = add i1 %a1a2, 1
    %a1b2 = extractvalue { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %a12, 0
    %b3 = extractvalue { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %a12, 1
    %a1aa2 = extractvalue { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } %b3, 0
    %ba1 = extractvalue { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } %b3, 1
    %a1ba1 = extractvalue { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } %ba1, 0
    %a2b2 = extractvalue { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } %ba1, 1
    %xda3 = and i1 %xbaa2, %a1aa2
    %xea3 = insertvalue { i1, { i64, { i64, { i64, i8* } } } } zeroinitializer, i1 %xda3, 0
    %r = insertvalue { i1, { i64, { i64, { i64, i8* } } } } %xea3, { i64, { i64, { i64, i8* } } } %a22, 1
    %c_1 = extractvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { i64, { i64, { i64, i8* } } } } %xba, 0
    %c_2 = extractvalue { { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } }, { i64, { i64, { i64, i8* } } } } %xba, 1
    call void @LRAT_Checker_Impl_cs_op_free ({ i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %c_1)
    ret { i1, { i64, { i64, { i64, i8* } } } } %r
}

define { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } @LRAT_Checker_Impl_start_proof_error_impl({ i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %x) #0 {

  start:
    %a1 = extractvalue { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %x, 0
    %b = extractvalue { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %x, 1
    %a1a = extractvalue { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %b, 0
    %ba = extractvalue { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %b, 1
    %a1b = extractvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %ba, 0
    %a2b = extractvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %ba, 1
    %xg = insertvalue { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } zeroinitializer, i1 1, 0
    %xha = insertvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } zeroinitializer, { i32, { i64, { i64, i32* } } } %a1b, 0
    %tmpaa = insertvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %xha, { i64, i32** } %a2b, 1
    %xja = insertvalue { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } zeroinitializer, { { i64, i1* }, { i64, { i64, i32* } } } %a1a, 0
    %tmpab = insertvalue { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %xja, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %tmpaa, 1
    %xka = insertvalue { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } zeroinitializer, i1 0, 0
    %tmpcc = insertvalue { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %xka, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %tmpab, 1
    %x1 = insertvalue { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } %xg, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %tmpcc, 1
    ret { i1, { i1, { { { i64, i1* }, { i64, { i64, i32* } } }, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } } %x1
}

define { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } @CNF_Parser_Impl_builder_abort_clause_impl({ i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %x) #0 {

  start:
    %a1 = extractvalue { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %x, 0
    %xb = extractvalue { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %x, 1
    %a1a = extractvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %xb, 0
    %a2a = extractvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %xb, 1
    %xaa = call { i32, { i64, { i64, i32* } } } @DS_Clause_Builder_cbld_abort_clause_impl ({ i32, { i64, { i64, i32* } } } %a1a)
    %xba = insertvalue { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } zeroinitializer, i64 %a1, 0
    %xfa = insertvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } zeroinitializer, { i32, { i64, { i64, i32* } } } %xaa, 0
    %tmpaa = insertvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %xfa, { i64, i32** } %a2a, 1
    %x1 = insertvalue { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %xba, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %tmpaa, 1
    ret { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %x1
}

define { i1, i64 } @CNF_Parser_Impl_parse_maybe_p_header_impl({ i8*, i64 } %x, i64 %x1) #0 {

  start:
    %a1 = extractvalue { i8*, i64 } %x, 0
    %a2 = extractvalue { i8*, i64 } %x, 1
    %x2 = sub i64 %a2, %x1
    %xa = icmp eq i64 %x2, 0
    br i1 %xa, label %then, label %else

  then:
    %xb = insertvalue { i1, i64 } zeroinitializer, i1 1, 0
    %x3 = insertvalue { i1, i64 } %xb, i64 %x1, 1
    br label %ctd_if

  else:
    %a1a = extractvalue { i8*, i64 } %x, 0
    %a2a = extractvalue { i8*, i64 } %x, 1
    %xb1 = getelementptr i8, i8* %a1a, i64 %x1
    %xc = load i8, i8* %xb1
    %xd = icmp eq i8 %xc, 112
    br i1 %xd, label %thena, label %elsea

  thena:
    %x4 = call { i1, i64 } @CNF_Parser_Impl_parse_skip_block_impl (i8 112, { i8*, i64 } %x, i64 %x1)
    br label %ctd_ifa

  elsea:
    %xe = insertvalue { i1, i64 } zeroinitializer, i1 0, 0
    %x5 = insertvalue { i1, i64 } %xe, i64 %x1, 1
    br label %ctd_ifa

  ctd_ifa:
    %x6 = phi { i1, i64 } [ %x5, %elsea ], [ %x4, %thena ]
    br label %ctd_if

  ctd_if:
    %x7 = phi { i1, i64 } [ %x6, %ctd_ifa ], [ %x3, %then ]
    ret { i1, i64 } %x7
}

define { i32*, { i32, { i64, { i64, i32* } } } } @DS_Clause_Builder_cbld_finish_clause_impl({ i32, { i64, { i64, i32* } } } %x) #0 {

  start:
    %a = extractvalue { i32, { i64, { i64, i32* } } } %x, 0
    %b = extractvalue { i32, { i64, { i64, i32* } } } %x, 1
    %xc = insertvalue { i32, { { i64, { i64, i32* } }, i1 } } zeroinitializer, i32 %a, 0
    %xda = insertvalue { { i64, { i64, i32* } }, i1 } zeroinitializer, { i64, { i64, i32* } } %b, 0
    %tmpba = insertvalue { { i64, { i64, i32* } }, i1 } %xda, i1 zeroinitializer, 1
    %tmpc = insertvalue { i32, { { i64, { i64, i32* } }, i1 } } %xc, { { i64, { i64, i32* } }, i1 } %tmpba, 1
    %a1 = extractvalue { i32, { { i64, { i64, i32* } }, i1 } } %tmpc, 0
    %aa = extractvalue { i32, { i64, { i64, i32* } } } %x, 0
    %ba = extractvalue { i32, { i64, { i64, i32* } } } %x, 1
    %xba = insertvalue { i32, { { i64, { i64, i32* } }, i1 } } zeroinitializer, i32 %aa, 0
    %xja = insertvalue { { i64, { i64, i32* } }, i1 } zeroinitializer, { i64, { i64, i32* } } %ba, 0
    %tmpac = insertvalue { { i64, { i64, i32* } }, i1 } %xja, i1 zeroinitializer, 1
    %tmpad = insertvalue { i32, { { i64, { i64, i32* } }, i1 } } %xba, { { i64, { i64, i32* } }, i1 } %tmpac, 1
    %xdaa = extractvalue { i32, { { i64, { i64, i32* } }, i1 } } %tmpad, 1
    %a1a = extractvalue { { i64, { i64, i32* } }, i1 } %xdaa, 0
    %a2a = extractvalue { { i64, { i64, i32* } }, i1 } %xdaa, 1
    %xaaa = call i32* @DS_Clause_zcl_make_impl ({ i64, { i64, i32* } } %a1a)
    %xbaa = call { i64, { i64, i32* } } @DS_Clause_Buffer_cbuf_flush_impl ({ i64, { i64, i32* } } %a1a)
    %xcaa = insertvalue { i32, { i64, { i64, i32* } } } zeroinitializer, i32 %a1, 0
    %xdaaa = insertvalue { i32, { i64, { i64, i32* } } } %xcaa, { i64, { i64, i32* } } %xbaa, 1
    %xeaaa = insertvalue { i32*, { i32, { i64, { i64, i32* } } } } zeroinitializer, i32* %xaaa, 0
    %x1 = insertvalue { i32*, { i32, { i64, { i64, i32* } } } } %xeaaa, { i32, { i64, { i64, i32* } } } %xdaaa, 1
    ret { i32*, { i32, { i64, { i64, i32* } } } } %x1
}

define void @Debugging_Tools_ll_dbg_tag_info_code_impl(i64 %x, i64 %x1) #0 {

  start:
    ret void
}

define { i1, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } @CNF_Parser_Impl_builder_finish_clause_impl({ i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %x) #0 {

  start:
    %a1 = extractvalue { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %x, 0
    %xb = extractvalue { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %x, 1
    %a1a = extractvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %xb, 0
    %a2a = extractvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %xb, 1
    %r = sub i64 0, 1
    %xaa = lshr i64 %r, 1
    %xba = sub i64 %xaa, 2
    %xca = icmp sle i64 %a1, %xba
    br i1 %xca, label %then, label %else

  then:
    %xda = add i64 %a1, 1
    %xea = insertvalue { i64, i1 } zeroinitializer, i64 %xda, 0
    %x1 = insertvalue { i64, i1 } %xea, i1 0, 1
    br label %ctd_if

  else:
    %xda1 = insertvalue { i64, i1 } zeroinitializer, i64 %a1, 0
    %x2 = insertvalue { i64, i1 } %xda1, i1 1, 1
    br label %ctd_if

  ctd_if:
    %xda2 = phi { i64, i1 } [ %x2, %else ], [ %x1, %then ]
    %a1b = extractvalue { i64, i1 } %xda2, 0
    %a2b = extractvalue { i64, i1 } %xda2, 1
    %xea1 = add i1 %a2b, 1
    br i1 %xea1, label %thena, label %elsea

  thena:
    %xfa = call { i32*, { i32, { i64, { i64, i32* } } } } @DS_Clause_Builder_cbld_finish_clause_impl ({ i32, { i64, { i64, i32* } } } %a1a)
    %a1c = extractvalue { i32*, { i32, { i64, { i64, i32* } } } } %xfa, 0
    %a2c = extractvalue { i32*, { i32, { i64, { i64, i32* } } } } %xfa, 1
    %xga = call { i64, i32** } @DS_Clause_Database_cdb_insert_impl (i64 %a1, i32* %a1c, { i64, i32** } %a2a)
    %xha = insertvalue { i1, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } zeroinitializer, i1 %a2b, 0
    %xo = insertvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } zeroinitializer, { i32, { i64, { i64, i32* } } } %a2c, 0
    %tmpb = insertvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %xo, { i64, i32** } %xga, 1
    %xp = insertvalue { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } zeroinitializer, i64 %a1b, 0
    %tmpc = insertvalue { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %xp, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %tmpb, 1
    %x3 = insertvalue { i1, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %xha, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %tmpc, 1
    br label %ctd_ifa

  elsea:
    %xfa1 = call { i32, { i64, { i64, i32* } } } @DS_Clause_Builder_cbld_abort_clause_impl ({ i32, { i64, { i64, i32* } } } %a1a)
    %xga1 = insertvalue { i1, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } zeroinitializer, i1 %a2b, 0
    %xm = insertvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } zeroinitializer, { i32, { i64, { i64, i32* } } } %xfa1, 0
    %tmpb1 = insertvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %xm, { i64, i32** } %a2a, 1
    %xn = insertvalue { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } zeroinitializer, i64 %a1, 0
    %tmpc1 = insertvalue { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %xn, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %tmpb1, 1
    %x4 = insertvalue { i1, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %xga1, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %tmpc1, 1
    br label %ctd_ifa

  ctd_ifa:
    %x5 = phi { i1, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } [ %x4, %elsea ], [ %x3, %thena ]
    ret { i1, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %x5
}

define { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } @CNF_Parser_Impl_parse_cnf_aux_formula2_impl(i64 %x, { i8*, i64 } %x1, i64 %x2) #0 {

  start:
    %xa = insertvalue { i64, i1 } zeroinitializer, i64 %x2, 0
    %xaa = insertvalue { i64, i1 } %xa, i1 0, 1
    br label %while_start

  while_start:
    %xba = phi { i64, i1 } [ %x7, %ctd_if ], [ %xaa, %start ]
    %a1 = extractvalue { i64, i1 } %xba, 0
    %a2 = extractvalue { i64, i1 } %xba, 1
    %xaaa = add i1 %a2, 1
    %a1a = extractvalue { i8*, i64 } %x1, 0
    %a2a = extractvalue { i8*, i64 } %x1, 1
    %xbaa = sub i64 %a2a, %a1
    %xca = icmp eq i64 %xbaa, 0
    %x3 = add i1 %xca, 1
    %x4 = and i1 %xaaa, %x3
    br i1 %x4, label %while_body, label %while_end

  while_body:
    %a11 = extractvalue { i64, i1 } %xba, 0
    %a21 = extractvalue { i64, i1 } %xba, 1
    %a1a1 = extractvalue { i8*, i64 } %x1, 0
    %a2a1 = extractvalue { i8*, i64 } %x1, 1
    %xaaa1 = getelementptr i8, i8* %a1a1, i64 %a11
    %xbaa1 = load i8, i8* %xaaa1
    %xca1 = icmp eq i8 %xbaa1, 32
    %xda = icmp ule i8 9, %xbaa1
    %xea = icmp ule i8 %xbaa1, 13
    %xfa = and i1 %xda, %xea
    %xga = or i1 %xca1, %xfa
    br i1 %xga, label %then, label %else

  then:
    %a1b = extractvalue { i8*, i64 } %x1, 0
    %a2b = extractvalue { i8*, i64 } %x1, 1
    %xha = add i64 %a11, 1
    %xia = insertvalue { i64, i1 } zeroinitializer, i64 %xha, 0
    %x5 = insertvalue { i64, i1 } %xia, i1 0, 1
    br label %ctd_if

  else:
    %xha1 = insertvalue { i64, i1 } zeroinitializer, i64 %a11, 0
    %x6 = insertvalue { i64, i1 } %xha1, i1 1, 1
    br label %ctd_if

  ctd_if:
    %x7 = phi { i64, i1 } [ %x6, %else ], [ %x5, %then ]
    br label %while_start

  while_end:
    %a12 = extractvalue { i64, i1 } %xba, 0
    %a22 = extractvalue { i64, i1 } %xba, 1
    %a1a2 = extractvalue { i8*, i64 } %x1, 0
    %a2a2 = extractvalue { i8*, i64 } %x1, 1
    %xaaa2 = sub i64 %a2a2, %a12
    %xbaa2 = call { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } @CNF_Parser_Impl_builder_init_impl (i64 %x, i64 %xaaa2)
    %a1b1 = extractvalue { i8*, i64 } %x1, 0
    %a2b1 = extractvalue { i8*, i64 } %x1, 1
    %xca2 = sub i64 %a2b1, %a12
    %xda1 = icmp eq i64 %xca2, 0
    br i1 %xda1, label %thena, label %elsea

  thena:
    %xja = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 } zeroinitializer, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %xbaa2, 0
    %tmpab = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 } %xja, i1 0, 1
    %xea1 = insertvalue { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } zeroinitializer, { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 } %tmpab, 0
    %x8 = insertvalue { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } %xea1, i64 %a12, 1
    br label %ctd_ifa

  elsea:
    %xea2 = call { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } @CNF_Parser_Impl_parse_clause2_impl ({ i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %xbaa2, { i8*, i64 } %x1, i64 %a12)
    %a1aa = extractvalue { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } %xea2, 0
    %a2aa = extractvalue { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } %xea2, 1
    %a1ba = extractvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 } %a1aa, 0
    %a2ba = extractvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 } %a1aa, 1
    br i1 %a2ba, label %thenb, label %elseb

  thenb:
    %xfa1 = call { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } @CNF_Parser_Impl_builder_abort_clause_impl ({ i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %a1ba)
    %xna = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 } zeroinitializer, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %xfa1, 0
    %tmpab1 = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 } %xna, i1 1, 1
    %xga1 = insertvalue { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } zeroinitializer, { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 } %tmpab1, 0
    %x9 = insertvalue { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } %xga1, i64 %a2aa, 1
    br label %ctd_ifb

  elseb:
    %xfa2 = call { i1, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } @CNF_Parser_Impl_builder_finish_clause_impl ({ i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %a1ba)
    %a1c = extractvalue { i1, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %xfa2, 0
    %a2c = extractvalue { i1, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } } %xfa2, 1
    br i1 %a1c, label %thenc, label %elsec

  thenc:
    %xpa = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 } zeroinitializer, { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %a2c, 0
    %tmpaaa = insertvalue { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 } %xpa, i1 %a1c, 1
    %xga2 = insertvalue { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } zeroinitializer, { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 } %tmpaaa, 0
    %x10 = insertvalue { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } %xga2, i64 %a2aa, 1
    br label %ctd_ifc

  elsec:
    %x11 = call { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } @CNF_Parser_Impl_parse_cnf_loop2_impl ({ i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %a2c, { i8*, i64 } %x1, i64 %a2aa)
    br label %ctd_ifc

  ctd_ifc:
    %x12 = phi { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } [ %x11, %elsec ], [ %x10, %thenc ]
    br label %ctd_ifb

  ctd_ifb:
    %x13 = phi { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } [ %x12, %ctd_ifc ], [ %x9, %thenb ]
    br label %ctd_ifa

  ctd_ifa:
    %x14 = phi { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } [ %x13, %ctd_ifb ], [ %x8, %thena ]
    ret { { { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } }, i1 }, i64 } %x14
}

define void @LRAT_Checker_Impl_ll_dbg_tag_parsed_cnf_impl(i8 %x) #0 {

  start:
    ret void
}

define { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } @LRAT_Checker_Impl_builder_finish_building_impl({ i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %x) #0 {

  start:
    %a1 = extractvalue { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %x, 0
    %xb = extractvalue { i64, { { i32, { i64, { i64, i32* } } }, { i64, i32** } } } %x, 1
    %a1a = extractvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %xb, 0
    %a2a = extractvalue { { i32, { i64, { i64, i32* } } }, { i64, i32** } } %xb, 1
    %xaa = call i32 @DS_Clause_Builder_cbld_get_maxlit_impl ({ i32, { i64, { i64, i32* } } } %a1a)
    call void @Debugging_Tools_ll_dbg_tag_info_code_impl (i64 1, i64 %a1)
    %xda = zext i32 %xaa to i64
    call void @Debugging_Tools_ll_dbg_tag_info_code_impl (i64 2, i64 %xda)
    %xfa = call { { i64, i1* }, { i64, { i64, i32* } } } @DS_Reversible_Assignment_rpan_empty_impl (i32 %xaa, i64 0)
    %xga = insertvalue { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } zeroinitializer, i1 0, 0
    %xha = insertvalue { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } zeroinitializer, { i32, { i64, { i64, i32* } } } %a1a, 0
    %tmpab = insertvalue { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } %xha, { { i64, i1* }, { i64, { i64, i32* } } } %xfa, 1
    %xja = insertvalue { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } zeroinitializer, { i64, i32** } %a2a, 0
    %tmpac = insertvalue { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } %xja, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } %tmpab, 1
    %xka = insertvalue { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } zeroinitializer, i1 0, 0
    %tmpdc = insertvalue { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } %xka, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } %tmpac, 1
    %x1 = insertvalue { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %xga, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } %tmpdc, 1
    ret { i1, { i1, { { i64, i32** }, { { i32, { i64, { i64, i32* } } }, { { i64, i1* }, { i64, { i64, i32* } } } } } } } %x1
}

define { i64, i1* } @DS_Reversible_Assignment_bla_set_checked_aux_impl({ i64, i1* } %x, i32 %x1, i1 %x2) #0 {

  start:
    %a1 = extractvalue { i64, i1* } %x, 0
    %a2 = extractvalue { i64, i1* } %x, 1
    %max = sub i32 0, 1
    %maxa = zext i32 %max to i64
    %maxb = add i64 %maxa, 1
    %ns = mul i64 %a1, 3
    %nsa = udiv i64 %a1, 2
    %do_max = icmp sle i64 %maxb, %nsa
    br i1 %do_max, label %then, label %else

  then:
    br label %ctd_if

  else:
    %ns1 = zext i32 %x1 to i64
    %ns_a = add i64 %ns1, 1
    %take_ns = icmp sle i64 %ns_a, %nsa
    br i1 %take_ns, label %thena, label %elsea

  thena:
    br label %ctd_ifa

  elsea:
    br label %ctd_ifa

  ctd_ifa:
    %x3 = phi i64 [ %ns_a, %elsea ], [ %nsa, %thena ]
    br label %ctd_if

  ctd_if:
    %nsb = phi i64 [ %x3, %ctd_ifa ], [ %maxb, %then ]
    %b = and i64 %nsb, 1
    %ba = icmp eq i64 %b, 0
    br i1 %ba, label %thenb, label %elseb

  thenb:
    br label %ctd_ifb

  elseb:
    %x4 = add i64 %nsb, 1
    br label %ctd_ifb

  ctd_ifb:
    %xaa = phi i64 [ %x4, %elseb ], [ %nsb, %thenb ]
    %a1a = extractvalue { i64, i1* } %x, 0
    %a2a = extractvalue { i64, i1* } %x, 1
    %xba = call i1* @LLVM_DS_NArray_array_grow (i64 %xaa, i64 %a1, i1* %a2a)
    %xca = insertvalue { i64, i1* } zeroinitializer, i64 %xaa, 0
    %xda = insertvalue { i64, i1* } %xca, i1* %xba, 1
    %xea = zext i32 %x1 to i64
    %a1b = extractvalue { i64, i1* } %xda, 0
    %a2b = extractvalue { i64, i1* } %xda, 1
    %p = getelementptr i1, i1* %a2b, i64 %xea
    store i1 %x2, i1* %p
    %xga = insertvalue { i64, i1* } zeroinitializer, i64 %a1b, 0
    %x5 = insertvalue { i64, i1* } %xga, i1* %a2b, 1
    ret { i64, i1* } %x5
}

define void @Monadify_M_CONST_LRAT_Sepref_Base_woarray_free_impl_Sepref_HOL_Bindings_dflt_option_free_option_LLVM_Shallow_ll_ptrcmp_eq_LLVM_Shallow_null_DS_Clause_zcl_free_impl(i64 %x, i32** %x1) #0 {

  start:
    %xa = insertvalue { i64, i32** } zeroinitializer, i64 0, 0
    %xaa = insertvalue { i64, i32** } %xa, i32** %x1, 1
    br label %while_start

  while_start:
    %xba = phi { i64, i32** } [ %x3, %ctd_if ], [ %xaa, %start ]
    %a1 = extractvalue { i64, i32** } %xba, 0
    %a2 = extractvalue { i64, i32** } %xba, 1
    %x2 = icmp slt i64 %a1, %x
    br i1 %x2, label %while_body, label %while_end

  while_body:
    %a11 = extractvalue { i64, i32** } %xba, 0
    %a21 = extractvalue { i64, i32** } %xba, 1
    %xaaa = getelementptr i32*, i32** %a21, i64 %a11
    %r = load i32*, i32** %xaaa
    %a = ptrtoint i32* null to i64
    %b = ptrtoint i32* %r to i64
    %d = icmp eq i64 %a, %b
    br i1 %d, label %then, label %else

  then:
    br label %ctd_if

  else:
    call void @DS_Clause_zcl_free_impl (i32* %r)
    br label %ctd_if

  ctd_if:
    %xca = add i64 %a11, 1
    %xda = insertvalue { i64, i32** } zeroinitializer, i64 %xca, 0
    %x3 = insertvalue { i64, i32** } %xda, i32** %a21, 1
    br label %while_start

  while_end:
    %a12 = extractvalue { i64, i32** } %xba, 0
    %x4 = extractvalue { i64, i32** } %xba, 1
    call void @LLVM_DS_NArray_narray_free3 (i32** %x4)
    ret void
}

define { i32, i1 } @Monadify_M_CONST_DS_Clause_Database_cdb_iterate_clause_impl_MMonad_Mreturn_Num_numeral_class_numeral_Num_num_One_MMonad_Mbind_LLVM_Shallow_ll_extract_value_Groups_zero_class_zero_MMonad_Mbind_LLVM_Shallow_ll_extract_value_Num_numeral_class_numeral_Num_num_One_MMonad_Mbind_LLVM_Shallow_ll_xor_Num_numeral_class_numeral_Num_num_One_MMonad_Mbind_LLVM_Shallow_ll_extract_value_Product_Type_prod_case_prod_Product_Type_Pair_Product_Type_Pair_LLVM_Shallow_llvm_rep_class_init_Groups_zero_class_zero_MMonad_Mbind_LLVM_Shallow_ll_extract_value_Product_Type_prod_case_prod_Product_Type_Pair_Product_Type_Pair_LLVM_Shallow_llvm_rep_class_init_Num_numeral_class_numeral_Num_num_One_MMonad_Mbind_LLVM_Shallow_ll_extract_value_Groups_zero_class_zero_MMonad_Mbind_LLVM_Shallow_ll_extract_value_Num_numeral_class_numeral_Num_num_One_MMonad_Mbind_LLVM_Shallow_ll_zext_Pure_type_MMonad_Mbind_LLVM_Shallow_ll_extract_value_Groups_zero_class_zero_MMonad_Mbind_LLVM_Shallow_ll_extract_value_Num_numeral_class_numeral_Num_num_One_MMonad_Mbind_LLVM_Shallow_ll_ofs_ptr_MMonad_Mbind_LLVM_Shallow_ll_load_LLVM_Shallow_llc_if_MMonad_Mbind_LLVM_Shallow_ll_insert_value_LLVM_Shallow_llvm_rep_class_init_Groups_zero_class_zero_LLVM_Shallow_ll_insert_value_Num_numeral_class_numeral_Num_num_One_MMonad_Mbind_LLVM_Shallow_ll_icmp_eq_Groups_zero_class_zero_LLVM_Shallow_llc_if_MMonad_Mbind_LLVM_Shallow_ll_insert_value_LLVM_Shallow_llvm_rep_class_init_Groups_zero_class_zero_LLVM_Shallow_ll_insert_value_Num_numeral_class_numeral_Num_num_One_MMonad_Mbind_LLVM_Shallow_ll_zext_Pure_type_MMonad_Mbind_Debugging_Tools_ll_dbg_tag_err_code_impl_Num_numeral_class_numeral_Num_num_Bit0_Num_num_One_MMonad_Mbind_LLVM_Shallow_ll_zext_Pure_type_MMonad_Mbind_Debugging_Tools_ll_dbg_tag_err_code_impl_Num_numeral_class_numeral_Num_num_Bit0_Num_num_One_MMonad_Mbind_LLVM_Shallow_ll_insert_value_LLVM_Shallow_llvm_rep_class_init_Groups_zero_class_zero_LLVM_Shallow_ll_insert_value_Num_numeral_class_numeral_Num_num_One_Num_numeral_class_numeral_Num_num_One({ i64, i32** } %x, i64 %x1, { { i64, i1* }, { i64, { i64, i32* } } } %x2, { i32, i1 } %x3) #0 {

  start:
    %a1 = extractvalue { i64, i32** } %x, 0
    %a2 = extractvalue { i64, i32** } %x, 1
    %xb = getelementptr i32*, i32** %a2, i64 %x1
    %xaa = load i32*, i32** %xb
    %xca = insertvalue { i64, i1 } zeroinitializer, i64 0, 0
    %tmpba = insertvalue { i64, i1 } %xca, i1 0, 1
    %xda = insertvalue { { i32, i1 }, { i64, i1 } } zeroinitializer, { i32, i1 } %x3, 0
    %xea = insertvalue { { i32, i1 }, { i64, i1 } } %xda, { i64, i1 } %tmpba, 1
    br label %while_start

  while_start:
    %xba = phi { { i32, i1 }, { i64, i1 } } [ %x12, %ctd_if ], [ %xea, %start ]
    %a1a = extractvalue { { i32, i1 }, { i64, i1 } } %xba, 0
    %xcaa = extractvalue { { i32, i1 }, { i64, i1 } } %xba, 1
    %a1aa = extractvalue { i64, i1 } %xcaa, 0
    %a2a = extractvalue { i64, i1 } %xcaa, 1
    %x4 = add i1 %a2a, 1
    %x5 = and i1 1, %x4
    br i1 %x5, label %while_body, label %while_end

  while_body:
    %a1a1 = extractvalue { { i32, i1 }, { i64, i1 } } %xba, 0
    %xcaa1 = extractvalue { { i32, i1 }, { i64, i1 } } %xba, 1
    %a1aa1 = extractvalue { i64, i1 } %xcaa1, 0
    %a2a1 = extractvalue { i64, i1 } %xcaa1, 1
    %xdaa = getelementptr i32, i32* %xaa, i64 %a1aa1
    %xeaa = load i32, i32* %xdaa
    %xfaa = icmp eq i32 %xeaa, 0
    br i1 %xfaa, label %then, label %else

  then:
    %xga = insertvalue { { i32, i1 }, { i64, i1 } } zeroinitializer, { i32, i1 } %a1a1, 0
    %xla = insertvalue { i64, i1 } zeroinitializer, i64 %a1aa1, 0
    %tmpea = insertvalue { i64, i1 } %xla, i1 1, 1
    %x6 = insertvalue { { i32, i1 }, { i64, i1 } } %xga, { i64, i1 } %tmpea, 1
    br label %ctd_if

  else:
    %a1b = extractvalue { i32, i1 } %a1a1, 0
    %a2b = extractvalue { i32, i1 } %a1a1, 1
    %xha = xor i32 %xeaa, 1
    %a = extractvalue { { i64, i1* }, { i64, { i64, i32* } } } %x2, 0
    %b = extractvalue { { i64, i1* }, { i64, { i64, i32* } } } %x2, 1
    %xna = insertvalue { { i64, i1* }, { { i64, { i64, i32* } }, i1 } } zeroinitializer, { i64, i1* } %a, 0
    %xq = insertvalue { { i64, { i64, i32* } }, i1 } zeroinitializer, { i64, { i64, i32* } } %b, 0
    %tmpcc = insertvalue { { i64, { i64, i32* } }, i1 } %xq, i1 zeroinitializer, 1
    %tmpcd = insertvalue { { i64, i1* }, { { i64, { i64, i32* } }, i1 } } %xna, { { i64, { i64, i32* } }, i1 } %tmpcc, 1
    %a1c = extractvalue { { i64, i1* }, { { i64, { i64, i32* } }, i1 } } %tmpcd, 0
    %aa = extractvalue { { i64, i1* }, { i64, { i64, i32* } } } %x2, 0
    %ba = extractvalue { { i64, i1* }, { i64, { i64, i32* } } } %x2, 1
    %xpa = insertvalue { { i64, i1* }, { { i64, { i64, i32* } }, i1 } } zeroinitializer, { i64, i1* } %aa, 0
    %xv = insertvalue { { i64, { i64, i32* } }, i1 } zeroinitializer, { i64, { i64, i32* } } %ba, 0
    %tmpdb = insertvalue { { i64, { i64, i32* } }, i1 } %xv, i1 zeroinitializer, 1
    %tmpdc = insertvalue { { i64, i1* }, { { i64, { i64, i32* } }, i1 } } %xpa, { { i64, { i64, i32* } }, i1 } %tmpdb, 1
    %xia = extractvalue { { i64, i1* }, { { i64, { i64, i32* } }, i1 } } %tmpdc, 1
    %a1ab = extractvalue { { i64, { i64, i32* } }, i1 } %xia, 0
    %a2aa = extractvalue { { i64, { i64, i32* } }, i1 } %xia, 1
    %bic = zext i32 %xha to i64
    %a1d = extractvalue { i64, i1* } %a1c, 0
    %a2c = extractvalue { i64, i1* } %a1c, 1
    %xja = getelementptr i1, i1* %a2c, i64 %bic
    %xka = load i1, i1* %xja
    br i1 %xka, label %thena, label %elsea

  thena:
    %xla1 = insertvalue { i32, i1 } zeroinitializer, i32 %a1b, 0
    %x7 = insertvalue { i32, i1 } %xla1, i1 %a2b, 1
    br label %ctd_ifa

  elsea:
    %xla2 = icmp eq i32 %a1b, 0
    br i1 %xla2, label %thenb, label %elseb

  thenb:
    %xma = insertvalue { i32, i1 } zeroinitializer, i32 %xeaa, 0
    %x8 = insertvalue { i32, i1 } %xma, i1 %a2b, 1
    br label %ctd_ifb

  elseb:
    %xma1 = zext i32 %xeaa to i64
    call void @Debugging_Tools_ll_dbg_tag_err_code_impl (i64 2, i64 %xma1)
    %xoaa = zext i32 %a1b to i64
    call void @Debugging_Tools_ll_dbg_tag_err_code_impl (i64 2, i64 %xoaa)
    %xqaa = insertvalue { i32, i1 } zeroinitializer, i32 %a1b, 0
    %x9 = insertvalue { i32, i1 } %xqaa, i1 1, 1
    br label %ctd_ifb

  ctd_ifb:
    %x10 = phi { i32, i1 } [ %x9, %elseb ], [ %x8, %thenb ]
    br label %ctd_ifa

  ctd_ifa:
    %xla3 = phi { i32, i1 } [ %x10, %ctd_ifb ], [ %x7, %thena ]
    %xma2 = add i64 %a1aa1, 1
    %xnaa = insertvalue { { i32, i1 }, { i64, i1 } } zeroinitializer, { i32, i1 } %xla3, 0
    %xxa = insertvalue { i64, i1 } zeroinitializer, i64 %xma2, 0
    %tmpga = insertvalue { i64, i1 } %xxa, i1 0, 1
    %x11 = insertvalue { { i32, i1 }, { i64, i1 } } %xnaa, { i64, i1 } %tmpga, 1
    br label %ctd_if

  ctd_if:
    %x12 = phi { { i32, i1 }, { i64, i1 } } [ %x11, %ctd_ifa ], [ %x6, %then ]
    br label %while_start

  while_end:
    %a1a2 = extractvalue { { i32, i1 }, { i64, i1 } } %xba, 0
    %xcaa2 = extractvalue { { i32, i1 }, { i64, i1 } } %xba, 1
    %a1aa2 = extractvalue { i64, i1 } %xcaa2, 0
    %a2a2 = extractvalue { i64, i1 } %xcaa2, 1
    ret { i32, i1 } %a1a2
}
